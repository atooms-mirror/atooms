<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>atooms.trajectory.base API documentation</title>
<meta name="description" content="Base trajectory classes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atooms.trajectory.base</code></h1>
</header>
<section id="section-intro">
<p>Base trajectory classes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of atooms
# Copyright 2010-2017, Daniele Coslovich

&#34;&#34;&#34;
Base trajectory classes.
&#34;&#34;&#34;

import os
import copy
import warnings


from .utils import get_block_size


# FutureWarning must show a traceback so that the user can localize the deprecation
# This should be moved up the chain
def _warn_with_traceback(message, category, filename, lineno, file=None, line=None):
    import traceback
    import sys
    if category is FutureWarning:
        traceback.print_stack(file=sys.stderr, limit=6)
    sys.stderr.write(warnings.formatwarning(message, category, filename, lineno, line))


warnings.showwarning = _warn_with_traceback


def canonicalize_fields(fields):
    from atooms.core.utils import canonicalize

    warnings.warn(&#39;canonicalize_fields() is deprecated, use canonicalize() instead&#39;, FutureWarning)
    th = TrajectoryBase(None)
    return canonicalize(fields, th.thesaurus)


class TrajectoryBase(object):
    &#34;&#34;&#34;
    Trajectory abstract base class.

    A trajectory is composed by one or several frames, each frame
    being a sample of a `System` taken at a given `step` during a
    simulation. Trajectory instances are iterable and behave as file
    objects: they can be opened and closed using the `with` syntax

    ```python
    with Trajectory(inpfile) as th:
        for system in th:
            pass
    ```

    alternatively

    ```python
    th = Trajectory(inpfile)
    for system in th:
        pass
    th.close()
    ```

    To write the state of a `System` to a trajectory, we must open the
    trajectory in write mode

    ```python
    with Trajectory(outfile, &#39;w&#39;) as th:
        th.write(system, step=0)
    ```

    Trajectories can use the `variables` attribute to define which system
    properties will be written to disk. Concrete classes may thus
    provide means to write arbitrary variables to disk via particle
    properties. Example:

    ```python
    for particle in system:
        particle.some_custom_property = 1.0
    with Trajectory(outfile, &#39;w&#39;) as th:
        th.variables = [&#39;position&#39;, &#39;some_custom_property&#39;]
        th.write(system, step=0)
    ```

    To be fully functional, concrete classes must implement
    `read_system()` and `write_system()` methods.

    `read()` is a template composed of the two following steps:

    - `read_init()`: called only once to initialize internal data
    structures, grab metadata, etc. Need *not* be implemented by
    subclasses.

    - `read_system(n)`: actually return the system at frame n. It must
      be implemented by subclasses.

    Similarly, `write()` is a template composed of `write_init()` and
    `write_system()`. Only the latter method must be implemented by
    subclasses.

    The `cache` variable reduces access time when reading the same
    trajectory multiple times. We use shallow copies to cut down the
    overhead. Cache is disabled by default as there is no control on
    its size yet.
    &#34;&#34;&#34;

    suffix = None

    def __init__(self, filename, mode=&#39;r&#39;, cache=False):
        self.filename = filename
        self.mode = mode
        &#34;&#34;&#34;Can be &#39;r&#39; (read) or &#39;w&#39; (write).&#34;&#34;&#34;
        self.callbacks = []
        &#34;&#34;&#34;List of callbacks to be applied to the system when reading a frame, see `add_callback()`&#34;&#34;&#34;
        self.precision = 6
        &#34;&#34;&#34;Number of digits used to write trajectory files.&#34;&#34;&#34;
        self.metadata = {}
        &#34;&#34;&#34;
        Dictionary of metadata about the trajectory. It can be used by
        subclasses to hold trajectory format info or dynamically
        on a per sample basis.
        &#34;&#34;&#34;
        self.thesaurus = {
            &#39;position&#39;: &#39;particle.position&#39;,
            &#39;velocity&#39;: &#39;particle.velocity&#39;,
            &#39;species&#39;: &#39;particle.species&#39;,
            &#39;radius&#39;: &#39;particle.radius&#39;,
            &#39;mass&#39;: &#39;particle.mass&#39;,
            &#39;pos&#39;: &#39;particle.position&#39;,
            &#39;x&#39;: &#39;particle.position[0]&#39;,
            &#39;y&#39;: &#39;particle.position[1]&#39;,
            &#39;z&#39;: &#39;particle.position[2]&#39;,
            &#39;vel&#39;: &#39;particle.velocity&#39;,
            &#39;vx&#39;: &#39;particle.velocity[0]&#39;,
            &#39;vy&#39;: &#39;particle.velocity[1]&#39;,
            &#39;vz&#39;: &#39;particle.velocity[2]&#39;,
            &#39;id&#39;: &#39;particle.species&#39;,
            &#39;type&#39;: &#39;particle.species&#39;,
            &#39;name&#39;: &#39;particle.species&#39;,
        }
        &#34;&#34;&#34;
        Dictionary of common shortcuts and synonims for system
        attributes. Can be updated by subclasses.
        &#34;&#34;&#34;

        # These are cached properties
        self._variables = ()
        &#34;&#34;&#34;
        Tuple of system attributes to be written by `write_system` and/or
        read by `read_system`. Its entries are canonicalized using
        `self.thesaurus` everytime the attribute is set. Subclasses
        may use it to allow the user to modify the trajectory layout
        or they can ignore it entirely.
        &#34;&#34;&#34;
        self._steps = None
        self._timestep = None
        self._grandcanonical = None
        self._block_size = None

        # Internal state
        self._overwrite = False
        self._initialized_write = False
        self._initialized_read = False
        # Sanity checks
        # Subclasses may define mode variants, such as r+, therefore the
        # autoritative mode is the first letter
        if self.mode[0] == &#39;r&#39; and self.filename is not None and \
           not os.path.exists(self.filename):
            raise IOError(&#39;trajectory file %s does not exist&#39; % self.filename)
        # Cache frames to optimize reading the same trajectory multiple times
        # We use shallow copies to cut down the overhead
        self.cache = cache
        &#34;&#34;&#34;If `True`, use a cache when reading the same frame multiple times&#34;&#34;&#34;
        self._cache = None

    def __len__(self):
        # We try first with read_len() which returns None by default
        frames = self.read_len()
        if frames is None:
            # We get the steps, which might take a bit longer
            return len(self.steps)
        else:
            return frames

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()

    def __iter__(self):
        for i in range(len(self.steps)):
            yield self.read(i)

    def __getitem__(self, key):
        if isinstance(key, slice):
            # This works but it loads the whole trajectory in ram.
            # If we make this a generator, then access a single sample
            # wont work.
            # The Sliced decorator doesn&#39;t have this issue.
            # Or just slice range(self.steps) instead.
            frames = range(len(self.steps))
            return [self.read(i) for i in frames[key]]

        elif isinstance(key, int):
            if key &lt; 0:
                key += len(self)
            if key &gt;= len(self):
                raise IndexError(&#34;Index (%d) is out of range (%d).&#34; % (key, len(self)))
            return self.read(key)

        else:
            raise TypeError(&#34;Invalid argument type [%s]&#34; % type(key))

    def append(self, system):
        &#34;&#34;&#34;Equivalent to `write(system)`.&#34;&#34;&#34;
        self.write(system)

    def close(self):
        &#34;&#34;&#34;Can be implemented by subclasses to close file handles.&#34;&#34;&#34;
        pass

    def read(self, index):
        &#34;&#34;&#34;Read and return system at frame `index`.&#34;&#34;&#34;
        if not self._initialized_read:
            self.read_init()
            self._initialized_read = True

        if self.cache and self._cache and index in self._cache:
            # We get the system from the cache
            system = self._cache[index]
        else:
            system = self.read_system(index)
            if self.cache:
                # Store the system in cache
                if self._cache is None:
                    self._cache = {}
                self._cache[index] = copy.copy(system)

        # Apply callbacks, class level and instance level
        #
        # Pass the frame index to the callback via system
        # by storing a &#34;temporary&#34; frame instance variable
        # (deleted after this loop)
        system.frame = index
        # Copying callbacks is an old hack that allowed client
        # code to safely pass variables in the callback across calls
        # Deprecating this feature would require checking if the
        # callback has variables not starting with __
        callbacks = copy.copy(self.callbacks)
        for cbk, args, kwargs in callbacks:
            system = cbk(system, *args, **kwargs)
        if hasattr(system, &#39;frame&#39;):
            del(system.frame)
        return system

    def write(self, system, step=None):
        &#34;&#34;&#34;
        Write `system` at a given integer `step`.

        If `step` is not provided, it is defined internally by
        incrementing by one the last added step, staring from zero.
        &#34;&#34;&#34;
        if self.mode[0] == &#39;r&#39;:
            raise IOError(&#39;trajectory file not open for writing&#39;)
        if not self._initialized_write:
            self.write_init(system)
            self._initialized_write = True

        # If we do not provide a step, we incrementally add 1 to the
        # last step, starting from 0.
        if step is not None:
            current_step = step
        else:
            if len(self.steps) == 0:
                current_step = 0
            else:
                current_step = self.steps[-1] + 1

        # If overwriting is not allowed (default), we check that we
        # are adding a step larger than the last added step.
        if not self._overwrite:
            if len(self.steps) &gt; 0 and current_step &lt;= self.steps[-1]:
                raise ValueError(&#39;cannot add step {} when overwrite is False&#39;.format(current_step))

        # Write the sample.
        self.write_system(system, current_step)
        # Step is added last, frame index starts from 0 by default.
        if step is None:
            self.steps.append(current_step)
        else:
            # If overwriting is allowed, we append the step only if it
            # not already there. This enables a small optimization by
            # avoiding this check if overwriting is off.
            if not self._overwrite:
                self.steps.append(current_step)
            else:
                if current_step not in self.steps:
                    self.steps.append(current_step)

    def read_init(self):
        &#34;&#34;&#34;
        Read metadata and/or set up data structures. Need not be
        implemented.
        &#34;&#34;&#34;
        pass

    def write_init(self, system):
        &#34;&#34;&#34;Subclass should use it to open files for writing.&#34;&#34;&#34;
        pass

    # These methods must be implemented by subclasses

    def read_system(self, frame):
        &#34;&#34;&#34;Return the system at the given `frame`.&#34;&#34;&#34;
        if hasattr(self, &#39;read_sample&#39;):
            warnings.warn(&#39;read_sample() is deprecated, use read_system()&#39;, DeprecationWarning)
            return self.read_sample(frame)
        else:
            raise NotImplementedError()

    def write_system(self, system, step):
        &#34;&#34;&#34;Write a `system` to file. Noting to return.&#34;&#34;&#34;
        if hasattr(self, &#39;write_sample&#39;):
            warnings.warn(&#39;write_sample() is deprecated, use write_system()&#39;, DeprecationWarning)
            return self.write_sample(system, step)
        else:
            raise NotImplementedError()

    # Callbacks will be applied to the output of read_system()

    def register_callback(self, cbk, *args, **kwargs):
        &#34;&#34;&#34;
        Register a callback `cbk` to be applied when reading a frame.

        The callback must receive a `System` instance as input an
        return the modified `System` instance as output.
        &#34;&#34;&#34;
        if (cbk, args, kwargs) not in self.callbacks:
            self.callbacks.append((cbk, args, kwargs))

    def add_callback(self, cbk, *args, **kwargs):
        &#34;&#34;&#34;Same as `register_callback()`.&#34;&#34;&#34;
        self.register_callback(cbk, *args, **kwargs)

    # To read/write timestep and block size sublcasses may implement
    # these methods. The default is dt=1 and block determined dynamically.

    def read_len(self):
        &#34;&#34;&#34;Return the number of frames. Optional.&#34;&#34;&#34;
        return None

    def read_steps(self):
        &#34;&#34;&#34;Return a list of steps.&#34;&#34;&#34;
        return []

    def read_timestep(self):
        &#34;&#34;&#34;Can be subclassed to parse the timestep.&#34;&#34;&#34;
        return 1.0

    def write_timestep(self, value):
        &#34;&#34;&#34;Set the timestep.&#34;&#34;&#34;
        self._timestep = value

    def read_block_size(self):
        &#34;&#34;&#34;
        Can be subclassed to parse the block size for trajectory with
        non-uniform intervals between frames (ex. exponential sampling).
        &#34;&#34;&#34;
        return None

    def write_block_size(self, value):
        &#34;&#34;&#34;Can be subclassed to write the block size.&#34;&#34;&#34;
        pass

    # Properties

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, value):
        from atooms.core.utils import canonicalize
        self._variables = canonicalize(value, self.thesaurus)

    def copy(self, cls=None, fout=None, only=None, include=None, exclude=None, steps=None):
        &#34;&#34;&#34;
        Return a copy of the trajectory
        &#34;&#34;&#34;
        from atooms.core.progress import progress
        from atooms.core.utils import canonicalize
        from atooms.core.utils import mkdir

        # Output class
        if cls is None:
            cls = self.__class__
        else:
            from atooms.trajectory import Trajectory
            if isinstance(cls, str):
                cls = Trajectory.formats[cls]

        # Make sure parent folder exists
        if fout is not None:
            mkdir(os.path.dirname(fout))

        # Copy trajectory
        conv = cls(fout, &#39;w&#39;)
        # In a previous version of trajectory conversion, we only
        # included the variables of the original trajectory, to allow
        # the output trajectory to include variables not present in
        # the original one. I do not think this makes sense. Suppose
        # the original trajectory did not store velocities, but the
        # output one writes them by default. The results will be wrong.
        variables = list(self.variables)
        if only is not None:
            variables = only
        if include is not None:
            for pattern in canonicalize(include, self.thesaurus):
                if pattern not in variables:
                    variables.append(pattern)
        if exclude is not None:
            for pattern in canonicalize(exclude, self.thesaurus):
                if pattern not in variables:
                    variables.append(pattern)
        conv.variables = variables
        conv.precision = self.precision
        conv.timestep = self.timestep
        conv.block_size = self.block_size
        # In python 3, zip returns a generator so this is ok
        #
        # for system, step in zip(inp, inp.steps):
        #     conv.write(system, step)
        #
        # In python 2, zipping t and t.steps will load everything
        # in RAM. In this case, it is better to use enumerate()
        if steps is None:
            for i, system in progress(enumerate(self), total=len(self)):
                conv.write(system, self.steps[i])
        else:
            # Only include requested steps (useful to prune
            # non-periodic trajectories)
            for step in steps:
                idx = self.steps.index(step)
                conv.write(self[idx], step)
        return conv

    @property
    def fields(self):
        warnings.warn(&#39;fields is deprecated, use variables instead&#39;, FutureWarning)
        return self.variables

    @fields.setter
    def fields(self, value):
        warnings.warn(&#39;fields is deprecated, use variables instead&#39;, FutureWarning)
        self._variables = value

    @property
    def steps(self):
        if self._steps is None:
            if self.mode[0] == &#39;r&#39;:
                self._steps = self.read_steps()
            else:
                self._steps = []
        return self._steps

    @steps.setter
    def steps(self, value):
        self._steps = value

    @property
    def timestep(self):
        if self._timestep is None:
            if self.mode[0] == &#39;r&#39;:
                self._timestep = self.read_timestep()
            else:
                self._timestep = 1.0
        return self._timestep

    @timestep.setter
    def timestep(self, value):
        self.write_timestep(value)
        self._timestep = value

    @property
    def block_size(self):
        &#34;&#34;&#34;
        Return the block size in frames of the trajectory.

        A block is a sequence of steps that repeats periodically in
        the trajectory. The block size is 1 for trajectories with
        constant time intervals between frames. A block size larger
        than 1 occurs with exponential sampling, ex. for steps
        sequences like 1,2,4,11,12,14,...
        &#34;&#34;&#34;
        if self._block_size is None:
            self._block_size = self.read_block_size()
        if self._block_size is None:
            # If size is still None (read_block_size is not
            # implemented) we determine it dynamically
            self._block_size = get_block_size(self.steps)
        return self._block_size

    @block_size.setter
    def block_size(self, value):
        self._block_size = value
        self.write_block_size(value)

    # Some additional useful properties

    @property
    def grandcanonical(self):
        &#34;&#34;&#34;
        True if the trajectory is grandcanonical, i.e. the number of
        particles changes.
        &#34;&#34;&#34;
        # In subclasses, cache it for efficiency, since we might have to discover it
        if self._grandcanonical is None:
            self._grandcanonical = False
        return self._grandcanonical

    @property
    def times(self):
        &#34;&#34;&#34;All available times.&#34;&#34;&#34;
        return [s*self.timestep for s in self.steps]

    @property
    def total_time(self):
        &#34;&#34;&#34;Total simulation time.&#34;&#34;&#34;
        return (self.steps[-1] - self.steps[0]) * self.timestep


class SuperTrajectory(TrajectoryBase):

    &#34;&#34;&#34;Collection of subtrajectories.&#34;&#34;&#34;

    # Optimized version

    def __init__(self, files, trajectoryclass, mode=&#39;r&#39;):
        &#34;&#34;&#34;
        Group a list of `files` into a single trajectory of class
        `trajectoryclass`.
        &#34;&#34;&#34;
        self.files = files
        if len(self.files) == 0:
            raise ValueError(&#39;no files found in %s&#39; % self.files)
        f = os.path.dirname(self.files[0])
        super(SuperTrajectory, self).__init__(f, mode)
        self.trajectoryclass = trajectoryclass

        # Make sure subtrajectories are sorted by increasing step
        # We look up the first step in each subtrajectory
        _step = []
        for f in self.files:
            with self.trajectoryclass(f) as t:
                _step.append(t.steps[0])
        _, self.files = zip(*sorted(zip(_step, self.files)))
        self.files = list(self.files)

        # This list holds the file containing a given step
        self._steps_file = []
        self._steps_frame = []
        # This caches the last trajectory used to minimize __init__() overhead
        self._last_trajectory = None
        self.steps = []
        for f in self.files:
            # This is slow, just to get the step index.
            # If we accept not to have the steps list updated at this stage
            # we can optimize this by about 10% on xyz files (16.12.2016)
            with self.trajectoryclass(f) as t:
                for j, step in enumerate(t.steps):
                    # The second test is to avoid storing twice the same frame
                    # if it appears at the end of a file and the beginning
                    # of the next file
                    if len(self.steps) == 0 or step != self.steps[-1]:
                        self.steps.append(step)
                        self._steps_file.append(f)
                        self._steps_frame.append(j)

        # Propagate variables
        with self.trajectoryclass(self.files[0]) as t:
            self.variables = t.variables

    def read_system(self, frame):
        # Optimization: use the last trajectory in cache (it works
        # well if frames are read sequentially)
        f = self._steps_file[frame]
        j = self._steps_frame[frame]

        # Note: if the file object has been closed in the meantime,
        # this approach will fail. In atooms 2, there was a check
        # whether the file object (trajectory attribute) was
        # closed. We will assume that decorators have no side
        # effects. If this needs to be fixed again, we can find a way.
        if self._last_trajectory is None:
            # First trajectory
            self._last_trajectory = self.trajectoryclass(f)
        elif self._last_trajectory.filename != f:
            # This is a new trajectory file
            self._last_trajectory.close()
            self._last_trajectory = self.trajectoryclass(f)
        else:
            # Already in cache, we just pass for clarity
            pass
        t = self._last_trajectory
        return t[j]

    def read_timestep(self):
        with self.trajectoryclass(self.files[0]) as t:
            return t.timestep

    def close(self):
        if self._last_trajectory is not None:
            self._last_trajectory.close()
            self._last_trajectory = None
        super(SuperTrajectory, self).close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="atooms.trajectory.base.canonicalize_fields"><code class="name flex">
<span>def <span class="ident">canonicalize_fields</span></span>(<span>fields)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canonicalize_fields(fields):
    from atooms.core.utils import canonicalize

    warnings.warn(&#39;canonicalize_fields() is deprecated, use canonicalize() instead&#39;, FutureWarning)
    th = TrajectoryBase(None)
    return canonicalize(fields, th.thesaurus)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atooms.trajectory.base.SuperTrajectory"><code class="flex name class">
<span>class <span class="ident">SuperTrajectory</span></span>
<span>(</span><span>files, trajectoryclass, mode='r')</span>
</code></dt>
<dd>
<div class="desc"><p>Collection of subtrajectories.</p>
<p>Group a list of <code>files</code> into a single trajectory of class
<code>trajectoryclass</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SuperTrajectory(TrajectoryBase):

    &#34;&#34;&#34;Collection of subtrajectories.&#34;&#34;&#34;

    # Optimized version

    def __init__(self, files, trajectoryclass, mode=&#39;r&#39;):
        &#34;&#34;&#34;
        Group a list of `files` into a single trajectory of class
        `trajectoryclass`.
        &#34;&#34;&#34;
        self.files = files
        if len(self.files) == 0:
            raise ValueError(&#39;no files found in %s&#39; % self.files)
        f = os.path.dirname(self.files[0])
        super(SuperTrajectory, self).__init__(f, mode)
        self.trajectoryclass = trajectoryclass

        # Make sure subtrajectories are sorted by increasing step
        # We look up the first step in each subtrajectory
        _step = []
        for f in self.files:
            with self.trajectoryclass(f) as t:
                _step.append(t.steps[0])
        _, self.files = zip(*sorted(zip(_step, self.files)))
        self.files = list(self.files)

        # This list holds the file containing a given step
        self._steps_file = []
        self._steps_frame = []
        # This caches the last trajectory used to minimize __init__() overhead
        self._last_trajectory = None
        self.steps = []
        for f in self.files:
            # This is slow, just to get the step index.
            # If we accept not to have the steps list updated at this stage
            # we can optimize this by about 10% on xyz files (16.12.2016)
            with self.trajectoryclass(f) as t:
                for j, step in enumerate(t.steps):
                    # The second test is to avoid storing twice the same frame
                    # if it appears at the end of a file and the beginning
                    # of the next file
                    if len(self.steps) == 0 or step != self.steps[-1]:
                        self.steps.append(step)
                        self._steps_file.append(f)
                        self._steps_frame.append(j)

        # Propagate variables
        with self.trajectoryclass(self.files[0]) as t:
            self.variables = t.variables

    def read_system(self, frame):
        # Optimization: use the last trajectory in cache (it works
        # well if frames are read sequentially)
        f = self._steps_file[frame]
        j = self._steps_frame[frame]

        # Note: if the file object has been closed in the meantime,
        # this approach will fail. In atooms 2, there was a check
        # whether the file object (trajectory attribute) was
        # closed. We will assume that decorators have no side
        # effects. If this needs to be fixed again, we can find a way.
        if self._last_trajectory is None:
            # First trajectory
            self._last_trajectory = self.trajectoryclass(f)
        elif self._last_trajectory.filename != f:
            # This is a new trajectory file
            self._last_trajectory.close()
            self._last_trajectory = self.trajectoryclass(f)
        else:
            # Already in cache, we just pass for clarity
            pass
        t = self._last_trajectory
        return t[j]

    def read_timestep(self):
        with self.trajectoryclass(self.files[0]) as t:
            return t.timestep

    def close(self):
        if self._last_trajectory is not None:
            self._last_trajectory.close()
            self._last_trajectory = None
        super(SuperTrajectory, self).close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atooms.trajectory.base.TrajectoryBase" href="#atooms.trajectory.base.TrajectoryBase">TrajectoryBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="atooms.trajectory.rumd.SuperTrajectoryRUMD" href="rumd.html#atooms.trajectory.rumd.SuperTrajectoryRUMD">SuperTrajectoryRUMD</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atooms.trajectory.base.TrajectoryBase" href="#atooms.trajectory.base.TrajectoryBase">TrajectoryBase</a></b></code>:
<ul class="hlist">
<li><code><a title="atooms.trajectory.base.TrajectoryBase.add_callback" href="#atooms.trajectory.base.TrajectoryBase.add_callback">add_callback</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.append" href="#atooms.trajectory.base.TrajectoryBase.append">append</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.block_size" href="#atooms.trajectory.base.TrajectoryBase.block_size">block_size</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.cache" href="#atooms.trajectory.base.TrajectoryBase.cache">cache</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.callbacks" href="#atooms.trajectory.base.TrajectoryBase.callbacks">callbacks</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.close" href="#atooms.trajectory.base.TrajectoryBase.close">close</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.copy" href="#atooms.trajectory.base.TrajectoryBase.copy">copy</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.grandcanonical" href="#atooms.trajectory.base.TrajectoryBase.grandcanonical">grandcanonical</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.metadata" href="#atooms.trajectory.base.TrajectoryBase.metadata">metadata</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.mode" href="#atooms.trajectory.base.TrajectoryBase.mode">mode</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.precision" href="#atooms.trajectory.base.TrajectoryBase.precision">precision</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read" href="#atooms.trajectory.base.TrajectoryBase.read">read</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_block_size" href="#atooms.trajectory.base.TrajectoryBase.read_block_size">read_block_size</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_init" href="#atooms.trajectory.base.TrajectoryBase.read_init">read_init</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_len" href="#atooms.trajectory.base.TrajectoryBase.read_len">read_len</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_steps" href="#atooms.trajectory.base.TrajectoryBase.read_steps">read_steps</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_system" href="#atooms.trajectory.base.TrajectoryBase.read_system">read_system</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_timestep" href="#atooms.trajectory.base.TrajectoryBase.read_timestep">read_timestep</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.register_callback" href="#atooms.trajectory.base.TrajectoryBase.register_callback">register_callback</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.thesaurus" href="#atooms.trajectory.base.TrajectoryBase.thesaurus">thesaurus</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.times" href="#atooms.trajectory.base.TrajectoryBase.times">times</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.total_time" href="#atooms.trajectory.base.TrajectoryBase.total_time">total_time</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write" href="#atooms.trajectory.base.TrajectoryBase.write">write</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_block_size" href="#atooms.trajectory.base.TrajectoryBase.write_block_size">write_block_size</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_init" href="#atooms.trajectory.base.TrajectoryBase.write_init">write_init</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_system" href="#atooms.trajectory.base.TrajectoryBase.write_system">write_system</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_timestep" href="#atooms.trajectory.base.TrajectoryBase.write_timestep">write_timestep</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase"><code class="flex name class">
<span>class <span class="ident">TrajectoryBase</span></span>
<span>(</span><span>filename, mode='r', cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Trajectory abstract base class.</p>
<p>A trajectory is composed by one or several frames, each frame
being a sample of a <code>System</code> taken at a given <code>step</code> during a
simulation. Trajectory instances are iterable and behave as file
objects: they can be opened and closed using the <code>with</code> syntax</p>
<pre><code class="language-python">with Trajectory(inpfile) as th:
    for system in th:
        pass
</code></pre>
<p>alternatively</p>
<pre><code class="language-python">th = Trajectory(inpfile)
for system in th:
    pass
th.close()
</code></pre>
<p>To write the state of a <code>System</code> to a trajectory, we must open the
trajectory in write mode</p>
<pre><code class="language-python">with Trajectory(outfile, 'w') as th:
    th.write(system, step=0)
</code></pre>
<p>Trajectories can use the <code>variables</code> attribute to define which system
properties will be written to disk. Concrete classes may thus
provide means to write arbitrary variables to disk via particle
properties. Example:</p>
<pre><code class="language-python">for particle in system:
    particle.some_custom_property = 1.0
with Trajectory(outfile, 'w') as th:
    th.variables = ['position', 'some_custom_property']
    th.write(system, step=0)
</code></pre>
<p>To be fully functional, concrete classes must implement
<code>read_system()</code> and <code>write_system()</code> methods.</p>
<p><code>read()</code> is a template composed of the two following steps:</p>
<ul>
<li>
<p><code>read_init()</code>: called only once to initialize internal data
structures, grab metadata, etc. Need <em>not</em> be implemented by
subclasses.</p>
</li>
<li>
<p><code>read_system(n)</code>: actually return the system at frame n. It must
be implemented by subclasses.</p>
</li>
</ul>
<p>Similarly, <code>write()</code> is a template composed of <code>write_init()</code> and
<code>write_system()</code>. Only the latter method must be implemented by
subclasses.</p>
<p>The <code>cache</code> variable reduces access time when reading the same
trajectory multiple times. We use shallow copies to cut down the
overhead. Cache is disabled by default as there is no control on
its size yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrajectoryBase(object):
    &#34;&#34;&#34;
    Trajectory abstract base class.

    A trajectory is composed by one or several frames, each frame
    being a sample of a `System` taken at a given `step` during a
    simulation. Trajectory instances are iterable and behave as file
    objects: they can be opened and closed using the `with` syntax

    ```python
    with Trajectory(inpfile) as th:
        for system in th:
            pass
    ```

    alternatively

    ```python
    th = Trajectory(inpfile)
    for system in th:
        pass
    th.close()
    ```

    To write the state of a `System` to a trajectory, we must open the
    trajectory in write mode

    ```python
    with Trajectory(outfile, &#39;w&#39;) as th:
        th.write(system, step=0)
    ```

    Trajectories can use the `variables` attribute to define which system
    properties will be written to disk. Concrete classes may thus
    provide means to write arbitrary variables to disk via particle
    properties. Example:

    ```python
    for particle in system:
        particle.some_custom_property = 1.0
    with Trajectory(outfile, &#39;w&#39;) as th:
        th.variables = [&#39;position&#39;, &#39;some_custom_property&#39;]
        th.write(system, step=0)
    ```

    To be fully functional, concrete classes must implement
    `read_system()` and `write_system()` methods.

    `read()` is a template composed of the two following steps:

    - `read_init()`: called only once to initialize internal data
    structures, grab metadata, etc. Need *not* be implemented by
    subclasses.

    - `read_system(n)`: actually return the system at frame n. It must
      be implemented by subclasses.

    Similarly, `write()` is a template composed of `write_init()` and
    `write_system()`. Only the latter method must be implemented by
    subclasses.

    The `cache` variable reduces access time when reading the same
    trajectory multiple times. We use shallow copies to cut down the
    overhead. Cache is disabled by default as there is no control on
    its size yet.
    &#34;&#34;&#34;

    suffix = None

    def __init__(self, filename, mode=&#39;r&#39;, cache=False):
        self.filename = filename
        self.mode = mode
        &#34;&#34;&#34;Can be &#39;r&#39; (read) or &#39;w&#39; (write).&#34;&#34;&#34;
        self.callbacks = []
        &#34;&#34;&#34;List of callbacks to be applied to the system when reading a frame, see `add_callback()`&#34;&#34;&#34;
        self.precision = 6
        &#34;&#34;&#34;Number of digits used to write trajectory files.&#34;&#34;&#34;
        self.metadata = {}
        &#34;&#34;&#34;
        Dictionary of metadata about the trajectory. It can be used by
        subclasses to hold trajectory format info or dynamically
        on a per sample basis.
        &#34;&#34;&#34;
        self.thesaurus = {
            &#39;position&#39;: &#39;particle.position&#39;,
            &#39;velocity&#39;: &#39;particle.velocity&#39;,
            &#39;species&#39;: &#39;particle.species&#39;,
            &#39;radius&#39;: &#39;particle.radius&#39;,
            &#39;mass&#39;: &#39;particle.mass&#39;,
            &#39;pos&#39;: &#39;particle.position&#39;,
            &#39;x&#39;: &#39;particle.position[0]&#39;,
            &#39;y&#39;: &#39;particle.position[1]&#39;,
            &#39;z&#39;: &#39;particle.position[2]&#39;,
            &#39;vel&#39;: &#39;particle.velocity&#39;,
            &#39;vx&#39;: &#39;particle.velocity[0]&#39;,
            &#39;vy&#39;: &#39;particle.velocity[1]&#39;,
            &#39;vz&#39;: &#39;particle.velocity[2]&#39;,
            &#39;id&#39;: &#39;particle.species&#39;,
            &#39;type&#39;: &#39;particle.species&#39;,
            &#39;name&#39;: &#39;particle.species&#39;,
        }
        &#34;&#34;&#34;
        Dictionary of common shortcuts and synonims for system
        attributes. Can be updated by subclasses.
        &#34;&#34;&#34;

        # These are cached properties
        self._variables = ()
        &#34;&#34;&#34;
        Tuple of system attributes to be written by `write_system` and/or
        read by `read_system`. Its entries are canonicalized using
        `self.thesaurus` everytime the attribute is set. Subclasses
        may use it to allow the user to modify the trajectory layout
        or they can ignore it entirely.
        &#34;&#34;&#34;
        self._steps = None
        self._timestep = None
        self._grandcanonical = None
        self._block_size = None

        # Internal state
        self._overwrite = False
        self._initialized_write = False
        self._initialized_read = False
        # Sanity checks
        # Subclasses may define mode variants, such as r+, therefore the
        # autoritative mode is the first letter
        if self.mode[0] == &#39;r&#39; and self.filename is not None and \
           not os.path.exists(self.filename):
            raise IOError(&#39;trajectory file %s does not exist&#39; % self.filename)
        # Cache frames to optimize reading the same trajectory multiple times
        # We use shallow copies to cut down the overhead
        self.cache = cache
        &#34;&#34;&#34;If `True`, use a cache when reading the same frame multiple times&#34;&#34;&#34;
        self._cache = None

    def __len__(self):
        # We try first with read_len() which returns None by default
        frames = self.read_len()
        if frames is None:
            # We get the steps, which might take a bit longer
            return len(self.steps)
        else:
            return frames

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()

    def __iter__(self):
        for i in range(len(self.steps)):
            yield self.read(i)

    def __getitem__(self, key):
        if isinstance(key, slice):
            # This works but it loads the whole trajectory in ram.
            # If we make this a generator, then access a single sample
            # wont work.
            # The Sliced decorator doesn&#39;t have this issue.
            # Or just slice range(self.steps) instead.
            frames = range(len(self.steps))
            return [self.read(i) for i in frames[key]]

        elif isinstance(key, int):
            if key &lt; 0:
                key += len(self)
            if key &gt;= len(self):
                raise IndexError(&#34;Index (%d) is out of range (%d).&#34; % (key, len(self)))
            return self.read(key)

        else:
            raise TypeError(&#34;Invalid argument type [%s]&#34; % type(key))

    def append(self, system):
        &#34;&#34;&#34;Equivalent to `write(system)`.&#34;&#34;&#34;
        self.write(system)

    def close(self):
        &#34;&#34;&#34;Can be implemented by subclasses to close file handles.&#34;&#34;&#34;
        pass

    def read(self, index):
        &#34;&#34;&#34;Read and return system at frame `index`.&#34;&#34;&#34;
        if not self._initialized_read:
            self.read_init()
            self._initialized_read = True

        if self.cache and self._cache and index in self._cache:
            # We get the system from the cache
            system = self._cache[index]
        else:
            system = self.read_system(index)
            if self.cache:
                # Store the system in cache
                if self._cache is None:
                    self._cache = {}
                self._cache[index] = copy.copy(system)

        # Apply callbacks, class level and instance level
        #
        # Pass the frame index to the callback via system
        # by storing a &#34;temporary&#34; frame instance variable
        # (deleted after this loop)
        system.frame = index
        # Copying callbacks is an old hack that allowed client
        # code to safely pass variables in the callback across calls
        # Deprecating this feature would require checking if the
        # callback has variables not starting with __
        callbacks = copy.copy(self.callbacks)
        for cbk, args, kwargs in callbacks:
            system = cbk(system, *args, **kwargs)
        if hasattr(system, &#39;frame&#39;):
            del(system.frame)
        return system

    def write(self, system, step=None):
        &#34;&#34;&#34;
        Write `system` at a given integer `step`.

        If `step` is not provided, it is defined internally by
        incrementing by one the last added step, staring from zero.
        &#34;&#34;&#34;
        if self.mode[0] == &#39;r&#39;:
            raise IOError(&#39;trajectory file not open for writing&#39;)
        if not self._initialized_write:
            self.write_init(system)
            self._initialized_write = True

        # If we do not provide a step, we incrementally add 1 to the
        # last step, starting from 0.
        if step is not None:
            current_step = step
        else:
            if len(self.steps) == 0:
                current_step = 0
            else:
                current_step = self.steps[-1] + 1

        # If overwriting is not allowed (default), we check that we
        # are adding a step larger than the last added step.
        if not self._overwrite:
            if len(self.steps) &gt; 0 and current_step &lt;= self.steps[-1]:
                raise ValueError(&#39;cannot add step {} when overwrite is False&#39;.format(current_step))

        # Write the sample.
        self.write_system(system, current_step)
        # Step is added last, frame index starts from 0 by default.
        if step is None:
            self.steps.append(current_step)
        else:
            # If overwriting is allowed, we append the step only if it
            # not already there. This enables a small optimization by
            # avoiding this check if overwriting is off.
            if not self._overwrite:
                self.steps.append(current_step)
            else:
                if current_step not in self.steps:
                    self.steps.append(current_step)

    def read_init(self):
        &#34;&#34;&#34;
        Read metadata and/or set up data structures. Need not be
        implemented.
        &#34;&#34;&#34;
        pass

    def write_init(self, system):
        &#34;&#34;&#34;Subclass should use it to open files for writing.&#34;&#34;&#34;
        pass

    # These methods must be implemented by subclasses

    def read_system(self, frame):
        &#34;&#34;&#34;Return the system at the given `frame`.&#34;&#34;&#34;
        if hasattr(self, &#39;read_sample&#39;):
            warnings.warn(&#39;read_sample() is deprecated, use read_system()&#39;, DeprecationWarning)
            return self.read_sample(frame)
        else:
            raise NotImplementedError()

    def write_system(self, system, step):
        &#34;&#34;&#34;Write a `system` to file. Noting to return.&#34;&#34;&#34;
        if hasattr(self, &#39;write_sample&#39;):
            warnings.warn(&#39;write_sample() is deprecated, use write_system()&#39;, DeprecationWarning)
            return self.write_sample(system, step)
        else:
            raise NotImplementedError()

    # Callbacks will be applied to the output of read_system()

    def register_callback(self, cbk, *args, **kwargs):
        &#34;&#34;&#34;
        Register a callback `cbk` to be applied when reading a frame.

        The callback must receive a `System` instance as input an
        return the modified `System` instance as output.
        &#34;&#34;&#34;
        if (cbk, args, kwargs) not in self.callbacks:
            self.callbacks.append((cbk, args, kwargs))

    def add_callback(self, cbk, *args, **kwargs):
        &#34;&#34;&#34;Same as `register_callback()`.&#34;&#34;&#34;
        self.register_callback(cbk, *args, **kwargs)

    # To read/write timestep and block size sublcasses may implement
    # these methods. The default is dt=1 and block determined dynamically.

    def read_len(self):
        &#34;&#34;&#34;Return the number of frames. Optional.&#34;&#34;&#34;
        return None

    def read_steps(self):
        &#34;&#34;&#34;Return a list of steps.&#34;&#34;&#34;
        return []

    def read_timestep(self):
        &#34;&#34;&#34;Can be subclassed to parse the timestep.&#34;&#34;&#34;
        return 1.0

    def write_timestep(self, value):
        &#34;&#34;&#34;Set the timestep.&#34;&#34;&#34;
        self._timestep = value

    def read_block_size(self):
        &#34;&#34;&#34;
        Can be subclassed to parse the block size for trajectory with
        non-uniform intervals between frames (ex. exponential sampling).
        &#34;&#34;&#34;
        return None

    def write_block_size(self, value):
        &#34;&#34;&#34;Can be subclassed to write the block size.&#34;&#34;&#34;
        pass

    # Properties

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, value):
        from atooms.core.utils import canonicalize
        self._variables = canonicalize(value, self.thesaurus)

    def copy(self, cls=None, fout=None, only=None, include=None, exclude=None, steps=None):
        &#34;&#34;&#34;
        Return a copy of the trajectory
        &#34;&#34;&#34;
        from atooms.core.progress import progress
        from atooms.core.utils import canonicalize
        from atooms.core.utils import mkdir

        # Output class
        if cls is None:
            cls = self.__class__
        else:
            from atooms.trajectory import Trajectory
            if isinstance(cls, str):
                cls = Trajectory.formats[cls]

        # Make sure parent folder exists
        if fout is not None:
            mkdir(os.path.dirname(fout))

        # Copy trajectory
        conv = cls(fout, &#39;w&#39;)
        # In a previous version of trajectory conversion, we only
        # included the variables of the original trajectory, to allow
        # the output trajectory to include variables not present in
        # the original one. I do not think this makes sense. Suppose
        # the original trajectory did not store velocities, but the
        # output one writes them by default. The results will be wrong.
        variables = list(self.variables)
        if only is not None:
            variables = only
        if include is not None:
            for pattern in canonicalize(include, self.thesaurus):
                if pattern not in variables:
                    variables.append(pattern)
        if exclude is not None:
            for pattern in canonicalize(exclude, self.thesaurus):
                if pattern not in variables:
                    variables.append(pattern)
        conv.variables = variables
        conv.precision = self.precision
        conv.timestep = self.timestep
        conv.block_size = self.block_size
        # In python 3, zip returns a generator so this is ok
        #
        # for system, step in zip(inp, inp.steps):
        #     conv.write(system, step)
        #
        # In python 2, zipping t and t.steps will load everything
        # in RAM. In this case, it is better to use enumerate()
        if steps is None:
            for i, system in progress(enumerate(self), total=len(self)):
                conv.write(system, self.steps[i])
        else:
            # Only include requested steps (useful to prune
            # non-periodic trajectories)
            for step in steps:
                idx = self.steps.index(step)
                conv.write(self[idx], step)
        return conv

    @property
    def fields(self):
        warnings.warn(&#39;fields is deprecated, use variables instead&#39;, FutureWarning)
        return self.variables

    @fields.setter
    def fields(self, value):
        warnings.warn(&#39;fields is deprecated, use variables instead&#39;, FutureWarning)
        self._variables = value

    @property
    def steps(self):
        if self._steps is None:
            if self.mode[0] == &#39;r&#39;:
                self._steps = self.read_steps()
            else:
                self._steps = []
        return self._steps

    @steps.setter
    def steps(self, value):
        self._steps = value

    @property
    def timestep(self):
        if self._timestep is None:
            if self.mode[0] == &#39;r&#39;:
                self._timestep = self.read_timestep()
            else:
                self._timestep = 1.0
        return self._timestep

    @timestep.setter
    def timestep(self, value):
        self.write_timestep(value)
        self._timestep = value

    @property
    def block_size(self):
        &#34;&#34;&#34;
        Return the block size in frames of the trajectory.

        A block is a sequence of steps that repeats periodically in
        the trajectory. The block size is 1 for trajectories with
        constant time intervals between frames. A block size larger
        than 1 occurs with exponential sampling, ex. for steps
        sequences like 1,2,4,11,12,14,...
        &#34;&#34;&#34;
        if self._block_size is None:
            self._block_size = self.read_block_size()
        if self._block_size is None:
            # If size is still None (read_block_size is not
            # implemented) we determine it dynamically
            self._block_size = get_block_size(self.steps)
        return self._block_size

    @block_size.setter
    def block_size(self, value):
        self._block_size = value
        self.write_block_size(value)

    # Some additional useful properties

    @property
    def grandcanonical(self):
        &#34;&#34;&#34;
        True if the trajectory is grandcanonical, i.e. the number of
        particles changes.
        &#34;&#34;&#34;
        # In subclasses, cache it for efficiency, since we might have to discover it
        if self._grandcanonical is None:
            self._grandcanonical = False
        return self._grandcanonical

    @property
    def times(self):
        &#34;&#34;&#34;All available times.&#34;&#34;&#34;
        return [s*self.timestep for s in self.steps]

    @property
    def total_time(self):
        &#34;&#34;&#34;Total simulation time.&#34;&#34;&#34;
        return (self.steps[-1] - self.steps[0]) * self.timestep</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="atooms.trajectory.base.SuperTrajectory" href="#atooms.trajectory.base.SuperTrajectory">SuperTrajectory</a></li>
<li><a title="atooms.trajectory.csv.TrajectoryCSV" href="csv.html#atooms.trajectory.csv.TrajectoryCSV">TrajectoryCSV</a></li>
<li><a title="atooms.trajectory.dynamo.TrajectoryDynamO" href="dynamo.html#atooms.trajectory.dynamo.TrajectoryDynamO">TrajectoryDynamO</a></li>
<li>atooms.trajectory.dynamo._TrajectoryDynamO</li>
<li><a title="atooms.trajectory.folder.TrajectoryFolder" href="folder.html#atooms.trajectory.folder.TrajectoryFolder">TrajectoryFolder</a></li>
<li><a title="atooms.trajectory.hoomd.TrajectoryHOOMD" href="hoomd.html#atooms.trajectory.hoomd.TrajectoryHOOMD">TrajectoryHOOMD</a></li>
<li><a title="atooms.trajectory.lammps.TrajectoryLAMMPS" href="lammps.html#atooms.trajectory.lammps.TrajectoryLAMMPS">TrajectoryLAMMPS</a></li>
<li><a title="atooms.trajectory.pdb.TrajectoryPDB" href="pdb.html#atooms.trajectory.pdb.TrajectoryPDB">TrajectoryPDB</a></li>
<li><a title="atooms.trajectory.ram.TrajectoryRam" href="ram.html#atooms.trajectory.ram.TrajectoryRam">TrajectoryRam</a></li>
<li><a title="atooms.trajectory.simple.TrajectorySimpleXYZ" href="simple.html#atooms.trajectory.simple.TrajectorySimpleXYZ">TrajectorySimpleXYZ</a></li>
<li><a title="atooms.trajectory.xyz.TrajectoryXYZ" href="xyz.html#atooms.trajectory.xyz.TrajectoryXYZ">TrajectoryXYZ</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="atooms.trajectory.base.TrajectoryBase.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="atooms.trajectory.base.TrajectoryBase.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<div class="desc"><p>Return the block size in frames of the trajectory.</p>
<p>A block is a sequence of steps that repeats periodically in
the trajectory. The block size is 1 for trajectories with
constant time intervals between frames. A block size larger
than 1 occurs with exponential sampling, ex. for steps
sequences like 1,2,4,11,12,14,&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def block_size(self):
    &#34;&#34;&#34;
    Return the block size in frames of the trajectory.

    A block is a sequence of steps that repeats periodically in
    the trajectory. The block size is 1 for trajectories with
    constant time intervals between frames. A block size larger
    than 1 occurs with exponential sampling, ex. for steps
    sequences like 1,2,4,11,12,14,...
    &#34;&#34;&#34;
    if self._block_size is None:
        self._block_size = self.read_block_size()
    if self._block_size is None:
        # If size is still None (read_block_size is not
        # implemented) we determine it dynamically
        self._block_size = get_block_size(self.steps)
    return self._block_size</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.cache"><code class="name">var <span class="ident">cache</span></code></dt>
<dd>
<div class="desc"><p>If <code>True</code>, use a cache when reading the same frame multiple times</p></div>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.callbacks"><code class="name">var <span class="ident">callbacks</span></code></dt>
<dd>
<div class="desc"><p>List of callbacks to be applied to the system when reading a frame, see <code>add_callback()</code></p></div>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.fields"><code class="name">var <span class="ident">fields</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fields(self):
    warnings.warn(&#39;fields is deprecated, use variables instead&#39;, FutureWarning)
    return self.variables</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.grandcanonical"><code class="name">var <span class="ident">grandcanonical</span></code></dt>
<dd>
<div class="desc"><p>True if the trajectory is grandcanonical, i.e. the number of
particles changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grandcanonical(self):
    &#34;&#34;&#34;
    True if the trajectory is grandcanonical, i.e. the number of
    particles changes.
    &#34;&#34;&#34;
    # In subclasses, cache it for efficiency, since we might have to discover it
    if self._grandcanonical is None:
        self._grandcanonical = False
    return self._grandcanonical</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of metadata about the trajectory. It can be used by
subclasses to hold trajectory format info or dynamically
on a per sample basis.</p></div>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<div class="desc"><p>Can be 'r' (read) or 'w' (write).</p></div>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.precision"><code class="name">var <span class="ident">precision</span></code></dt>
<dd>
<div class="desc"><p>Number of digits used to write trajectory files.</p></div>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.steps"><code class="name">var <span class="ident">steps</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def steps(self):
    if self._steps is None:
        if self.mode[0] == &#39;r&#39;:
            self._steps = self.read_steps()
        else:
            self._steps = []
    return self._steps</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.thesaurus"><code class="name">var <span class="ident">thesaurus</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of common shortcuts and synonims for system
attributes. Can be updated by subclasses.</p></div>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.times"><code class="name">var <span class="ident">times</span></code></dt>
<dd>
<div class="desc"><p>All available times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def times(self):
    &#34;&#34;&#34;All available times.&#34;&#34;&#34;
    return [s*self.timestep for s in self.steps]</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.timestep"><code class="name">var <span class="ident">timestep</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timestep(self):
    if self._timestep is None:
        if self.mode[0] == &#39;r&#39;:
            self._timestep = self.read_timestep()
        else:
            self._timestep = 1.0
    return self._timestep</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.total_time"><code class="name">var <span class="ident">total_time</span></code></dt>
<dd>
<div class="desc"><p>Total simulation time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total_time(self):
    &#34;&#34;&#34;Total simulation time.&#34;&#34;&#34;
    return (self.steps[-1] - self.steps[0]) * self.timestep</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.variables"><code class="name">var <span class="ident">variables</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def variables(self):
    return self._variables</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atooms.trajectory.base.TrajectoryBase.add_callback"><code class="name flex">
<span>def <span class="ident">add_callback</span></span>(<span>self, cbk, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Same as <code>register_callback()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_callback(self, cbk, *args, **kwargs):
    &#34;&#34;&#34;Same as `register_callback()`.&#34;&#34;&#34;
    self.register_callback(cbk, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, system)</span>
</code></dt>
<dd>
<div class="desc"><p>Equivalent to <code>write(system)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, system):
    &#34;&#34;&#34;Equivalent to `write(system)`.&#34;&#34;&#34;
    self.write(system)</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Can be implemented by subclasses to close file handles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Can be implemented by subclasses to close file handles.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, cls=None, fout=None, only=None, include=None, exclude=None, steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a copy of the trajectory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, cls=None, fout=None, only=None, include=None, exclude=None, steps=None):
    &#34;&#34;&#34;
    Return a copy of the trajectory
    &#34;&#34;&#34;
    from atooms.core.progress import progress
    from atooms.core.utils import canonicalize
    from atooms.core.utils import mkdir

    # Output class
    if cls is None:
        cls = self.__class__
    else:
        from atooms.trajectory import Trajectory
        if isinstance(cls, str):
            cls = Trajectory.formats[cls]

    # Make sure parent folder exists
    if fout is not None:
        mkdir(os.path.dirname(fout))

    # Copy trajectory
    conv = cls(fout, &#39;w&#39;)
    # In a previous version of trajectory conversion, we only
    # included the variables of the original trajectory, to allow
    # the output trajectory to include variables not present in
    # the original one. I do not think this makes sense. Suppose
    # the original trajectory did not store velocities, but the
    # output one writes them by default. The results will be wrong.
    variables = list(self.variables)
    if only is not None:
        variables = only
    if include is not None:
        for pattern in canonicalize(include, self.thesaurus):
            if pattern not in variables:
                variables.append(pattern)
    if exclude is not None:
        for pattern in canonicalize(exclude, self.thesaurus):
            if pattern not in variables:
                variables.append(pattern)
    conv.variables = variables
    conv.precision = self.precision
    conv.timestep = self.timestep
    conv.block_size = self.block_size
    # In python 3, zip returns a generator so this is ok
    #
    # for system, step in zip(inp, inp.steps):
    #     conv.write(system, step)
    #
    # In python 2, zipping t and t.steps will load everything
    # in RAM. In this case, it is better to use enumerate()
    if steps is None:
        for i, system in progress(enumerate(self), total=len(self)):
            conv.write(system, self.steps[i])
    else:
        # Only include requested steps (useful to prune
        # non-periodic trajectories)
        for step in steps:
            idx = self.steps.index(step)
            conv.write(self[idx], step)
    return conv</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and return system at frame <code>index</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, index):
    &#34;&#34;&#34;Read and return system at frame `index`.&#34;&#34;&#34;
    if not self._initialized_read:
        self.read_init()
        self._initialized_read = True

    if self.cache and self._cache and index in self._cache:
        # We get the system from the cache
        system = self._cache[index]
    else:
        system = self.read_system(index)
        if self.cache:
            # Store the system in cache
            if self._cache is None:
                self._cache = {}
            self._cache[index] = copy.copy(system)

    # Apply callbacks, class level and instance level
    #
    # Pass the frame index to the callback via system
    # by storing a &#34;temporary&#34; frame instance variable
    # (deleted after this loop)
    system.frame = index
    # Copying callbacks is an old hack that allowed client
    # code to safely pass variables in the callback across calls
    # Deprecating this feature would require checking if the
    # callback has variables not starting with __
    callbacks = copy.copy(self.callbacks)
    for cbk, args, kwargs in callbacks:
        system = cbk(system, *args, **kwargs)
    if hasattr(system, &#39;frame&#39;):
        del(system.frame)
    return system</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read_block_size"><code class="name flex">
<span>def <span class="ident">read_block_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Can be subclassed to parse the block size for trajectory with
non-uniform intervals between frames (ex. exponential sampling).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_block_size(self):
    &#34;&#34;&#34;
    Can be subclassed to parse the block size for trajectory with
    non-uniform intervals between frames (ex. exponential sampling).
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read_init"><code class="name flex">
<span>def <span class="ident">read_init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read metadata and/or set up data structures. Need not be
implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_init(self):
    &#34;&#34;&#34;
    Read metadata and/or set up data structures. Need not be
    implemented.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read_len"><code class="name flex">
<span>def <span class="ident">read_len</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of frames. Optional.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_len(self):
    &#34;&#34;&#34;Return the number of frames. Optional.&#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read_steps"><code class="name flex">
<span>def <span class="ident">read_steps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_steps(self):
    &#34;&#34;&#34;Return a list of steps.&#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read_system"><code class="name flex">
<span>def <span class="ident">read_system</span></span>(<span>self, frame)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the system at the given <code>frame</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_system(self, frame):
    &#34;&#34;&#34;Return the system at the given `frame`.&#34;&#34;&#34;
    if hasattr(self, &#39;read_sample&#39;):
        warnings.warn(&#39;read_sample() is deprecated, use read_system()&#39;, DeprecationWarning)
        return self.read_sample(frame)
    else:
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.read_timestep"><code class="name flex">
<span>def <span class="ident">read_timestep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Can be subclassed to parse the timestep.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_timestep(self):
    &#34;&#34;&#34;Can be subclassed to parse the timestep.&#34;&#34;&#34;
    return 1.0</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.register_callback"><code class="name flex">
<span>def <span class="ident">register_callback</span></span>(<span>self, cbk, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a callback <code>cbk</code> to be applied when reading a frame.</p>
<p>The callback must receive a <code>System</code> instance as input an
return the modified <code>System</code> instance as output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_callback(self, cbk, *args, **kwargs):
    &#34;&#34;&#34;
    Register a callback `cbk` to be applied when reading a frame.

    The callback must receive a `System` instance as input an
    return the modified `System` instance as output.
    &#34;&#34;&#34;
    if (cbk, args, kwargs) not in self.callbacks:
        self.callbacks.append((cbk, args, kwargs))</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, system, step=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write <code>system</code> at a given integer <code>step</code>.</p>
<p>If <code>step</code> is not provided, it is defined internally by
incrementing by one the last added step, staring from zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, system, step=None):
    &#34;&#34;&#34;
    Write `system` at a given integer `step`.

    If `step` is not provided, it is defined internally by
    incrementing by one the last added step, staring from zero.
    &#34;&#34;&#34;
    if self.mode[0] == &#39;r&#39;:
        raise IOError(&#39;trajectory file not open for writing&#39;)
    if not self._initialized_write:
        self.write_init(system)
        self._initialized_write = True

    # If we do not provide a step, we incrementally add 1 to the
    # last step, starting from 0.
    if step is not None:
        current_step = step
    else:
        if len(self.steps) == 0:
            current_step = 0
        else:
            current_step = self.steps[-1] + 1

    # If overwriting is not allowed (default), we check that we
    # are adding a step larger than the last added step.
    if not self._overwrite:
        if len(self.steps) &gt; 0 and current_step &lt;= self.steps[-1]:
            raise ValueError(&#39;cannot add step {} when overwrite is False&#39;.format(current_step))

    # Write the sample.
    self.write_system(system, current_step)
    # Step is added last, frame index starts from 0 by default.
    if step is None:
        self.steps.append(current_step)
    else:
        # If overwriting is allowed, we append the step only if it
        # not already there. This enables a small optimization by
        # avoiding this check if overwriting is off.
        if not self._overwrite:
            self.steps.append(current_step)
        else:
            if current_step not in self.steps:
                self.steps.append(current_step)</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.write_block_size"><code class="name flex">
<span>def <span class="ident">write_block_size</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Can be subclassed to write the block size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_block_size(self, value):
    &#34;&#34;&#34;Can be subclassed to write the block size.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.write_init"><code class="name flex">
<span>def <span class="ident">write_init</span></span>(<span>self, system)</span>
</code></dt>
<dd>
<div class="desc"><p>Subclass should use it to open files for writing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_init(self, system):
    &#34;&#34;&#34;Subclass should use it to open files for writing.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.write_system"><code class="name flex">
<span>def <span class="ident">write_system</span></span>(<span>self, system, step)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a <code>system</code> to file. Noting to return.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_system(self, system, step):
    &#34;&#34;&#34;Write a `system` to file. Noting to return.&#34;&#34;&#34;
    if hasattr(self, &#39;write_sample&#39;):
        warnings.warn(&#39;write_sample() is deprecated, use write_system()&#39;, DeprecationWarning)
        return self.write_sample(system, step)
    else:
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="atooms.trajectory.base.TrajectoryBase.write_timestep"><code class="name flex">
<span>def <span class="ident">write_timestep</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the timestep.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_timestep(self, value):
    &#34;&#34;&#34;Set the timestep.&#34;&#34;&#34;
    self._timestep = value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atooms.trajectory" href="index.html">atooms.trajectory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="atooms.trajectory.base.canonicalize_fields" href="#atooms.trajectory.base.canonicalize_fields">canonicalize_fields</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atooms.trajectory.base.SuperTrajectory" href="#atooms.trajectory.base.SuperTrajectory">SuperTrajectory</a></code></h4>
</li>
<li>
<h4><code><a title="atooms.trajectory.base.TrajectoryBase" href="#atooms.trajectory.base.TrajectoryBase">TrajectoryBase</a></code></h4>
<ul class="two-column">
<li><code><a title="atooms.trajectory.base.TrajectoryBase.add_callback" href="#atooms.trajectory.base.TrajectoryBase.add_callback">add_callback</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.append" href="#atooms.trajectory.base.TrajectoryBase.append">append</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.block_size" href="#atooms.trajectory.base.TrajectoryBase.block_size">block_size</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.cache" href="#atooms.trajectory.base.TrajectoryBase.cache">cache</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.callbacks" href="#atooms.trajectory.base.TrajectoryBase.callbacks">callbacks</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.close" href="#atooms.trajectory.base.TrajectoryBase.close">close</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.copy" href="#atooms.trajectory.base.TrajectoryBase.copy">copy</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.fields" href="#atooms.trajectory.base.TrajectoryBase.fields">fields</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.grandcanonical" href="#atooms.trajectory.base.TrajectoryBase.grandcanonical">grandcanonical</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.metadata" href="#atooms.trajectory.base.TrajectoryBase.metadata">metadata</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.mode" href="#atooms.trajectory.base.TrajectoryBase.mode">mode</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.precision" href="#atooms.trajectory.base.TrajectoryBase.precision">precision</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read" href="#atooms.trajectory.base.TrajectoryBase.read">read</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_block_size" href="#atooms.trajectory.base.TrajectoryBase.read_block_size">read_block_size</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_init" href="#atooms.trajectory.base.TrajectoryBase.read_init">read_init</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_len" href="#atooms.trajectory.base.TrajectoryBase.read_len">read_len</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_steps" href="#atooms.trajectory.base.TrajectoryBase.read_steps">read_steps</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_system" href="#atooms.trajectory.base.TrajectoryBase.read_system">read_system</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.read_timestep" href="#atooms.trajectory.base.TrajectoryBase.read_timestep">read_timestep</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.register_callback" href="#atooms.trajectory.base.TrajectoryBase.register_callback">register_callback</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.steps" href="#atooms.trajectory.base.TrajectoryBase.steps">steps</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.suffix" href="#atooms.trajectory.base.TrajectoryBase.suffix">suffix</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.thesaurus" href="#atooms.trajectory.base.TrajectoryBase.thesaurus">thesaurus</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.times" href="#atooms.trajectory.base.TrajectoryBase.times">times</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.timestep" href="#atooms.trajectory.base.TrajectoryBase.timestep">timestep</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.total_time" href="#atooms.trajectory.base.TrajectoryBase.total_time">total_time</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.variables" href="#atooms.trajectory.base.TrajectoryBase.variables">variables</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write" href="#atooms.trajectory.base.TrajectoryBase.write">write</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_block_size" href="#atooms.trajectory.base.TrajectoryBase.write_block_size">write_block_size</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_init" href="#atooms.trajectory.base.TrajectoryBase.write_init">write_init</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_system" href="#atooms.trajectory.base.TrajectoryBase.write_system">write_system</a></code></li>
<li><code><a title="atooms.trajectory.base.TrajectoryBase.write_timestep" href="#atooms.trajectory.base.TrajectoryBase.write_timestep">write_timestep</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>