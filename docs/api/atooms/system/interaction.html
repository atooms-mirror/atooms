<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>atooms.system.interaction API documentation</title>
<meta name="description" content="Base and total interaction class â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atooms.system.interaction</code></h1>
</header>
<section id="section-intro">
<p>Base and total interaction class.</p>
<p>Actual interaction backends should implement this interface or
subclass Interaction by implementing the compute() method and
specifying the variables passed to it using the Interaction.variables
dictionary.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of atooms
# Copyright 2010-2017, Daniele Coslovich

&#34;&#34;&#34;
Base and total interaction class.

Actual interaction backends should implement this interface or
subclass Interaction by implementing the compute() method and
specifying the variables passed to it using the Interaction.variables
dictionary.
&#34;&#34;&#34;

import numpy


class InteractionBase(object):

    def __init__(self):
        self.variables = {&#39;position&#39;: &#39;particle.position&#39;}
        &#34;&#34;&#34;
        A dictionary of variables needed to compute the interaction

        The keys must match the variable names in the
        `Interaction.compute()` interface, the fields must be
        canonicalizable variables accepted by `System.dump()`.

        It is possible to specify the required data type using the
        optionl colon syntax &lt;property&gt;[:&lt;dtype&gt;]. The dtype must a
        valid identifier for numpy array creation.
        &#34;&#34;&#34;
        # TODO: order is not a good variable, we should expand the syntax using [:order]
        self.order = &#39;F&#39;  # deprecated
        self.observable = [&#39;energy&#39;, &#39;forces&#39;, &#39;virial&#39;, &#39;stress&#39;, &#39;hessian&#39;]
        for observable in self.observable:
            setattr(self, observable, None)

    def __add__(self, other):
        total = Interaction()
        for attr in self.observable:
            if getattr(self, attr) is None and getattr(other, attr) is None:
                continue
            elif getattr(self, attr) is not None and getattr(other, attr) is not None:
                # Store the sum of the properties in the total interaction
                setattr(total, attr, getattr(self, attr) + getattr(other, attr))
            else:
                raise ValueError(&#39;attribute {} not set in {} or {}&#39;.format(attr,
                                                                           self,
                                                                           other))
        return total

    def __radd__(self, other):
        if other == 0:
            return self
        else:
            return self.__add__(other)

    def compute(self, observable, position):
        &#34;&#34;&#34;
        Compute an `observable` from this interaction

        Subclasses must adapt the interface so as to match the keys
        specified by the `Interaction.variables` dict.
        &#34;&#34;&#34;
        # Sanity checks
        assert observable in self.observable, \
            &#39;unsupported observable {}&#39;.format(observable)

        # Zeroing observables
        ndim, N = position.shape
        if observable == &#39;energy&#39;:
            self.energy = 0.0
        elif observable == &#39;forces&#39; or observable is None:
            self.energy = 0.0
            self.virial = 0.0
            self.forces = numpy.zeros_like(position)
        elif observable == &#39;stress&#39;:
            self.energy = 0.0
            self.virial = 0.0
            self.forces = numpy.zeros_like(position)
            self.stress = numpy.zeros(ndim, ndim)
        elif observable == &#39;hessian&#39;:
            self.hessian = numpy.zeros((ndim, N, ndim, N))


class Interaction(InteractionBase):

    def __init__(self, *terms):
        InteractionBase.__init__(self)
        self.variables = {}
        self.term = []
        for term in terms:
            self.add(term)

    def add(self, term):
        self.term.append(term)
        self.variables.update(term.variables)

    def compute(self, observable, **kwargs):
        &#34;&#34;&#34;
        Compute an `observable` from all terms of this interaction
        &#34;&#34;&#34;
        if len(self.term) == 0:
            return

        for term in self.term:
            # Extract the relevant variables for this term
            term_kwargs = {}
            for key in term.variables:
                term_kwargs[key] = kwargs[key]
            term.compute(observable, **term_kwargs)

        # Sum all interaction terms
        total = sum(self.term)
        for attr in self.observable:
            setattr(self, attr, getattr(total, attr))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atooms.system.interaction.Interaction"><code class="flex name class">
<span>class <span class="ident">Interaction</span></span>
<span>(</span><span>*terms)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interaction(InteractionBase):

    def __init__(self, *terms):
        InteractionBase.__init__(self)
        self.variables = {}
        self.term = []
        for term in terms:
            self.add(term)

    def add(self, term):
        self.term.append(term)
        self.variables.update(term.variables)

    def compute(self, observable, **kwargs):
        &#34;&#34;&#34;
        Compute an `observable` from all terms of this interaction
        &#34;&#34;&#34;
        if len(self.term) == 0:
            return

        for term in self.term:
            # Extract the relevant variables for this term
            term_kwargs = {}
            for key in term.variables:
                term_kwargs[key] = kwargs[key]
            term.compute(observable, **term_kwargs)

        # Sum all interaction terms
        total = sum(self.term)
        for attr in self.observable:
            setattr(self, attr, getattr(total, attr))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atooms.system.interaction.InteractionBase" href="#atooms.system.interaction.InteractionBase">InteractionBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="atooms.backends.lammps.Interaction" href="../backends/lammps.html#atooms.backends.lammps.Interaction">Interaction</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="atooms.system.interaction.Interaction.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, term)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, term):
    self.term.append(term)
    self.variables.update(term.variables)</code></pre>
</details>
</dd>
<dt id="atooms.system.interaction.Interaction.compute"><code class="name flex">
<span>def <span class="ident">compute</span></span>(<span>self, observable, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an <code>observable</code> from all terms of this interaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute(self, observable, **kwargs):
    &#34;&#34;&#34;
    Compute an `observable` from all terms of this interaction
    &#34;&#34;&#34;
    if len(self.term) == 0:
        return

    for term in self.term:
        # Extract the relevant variables for this term
        term_kwargs = {}
        for key in term.variables:
            term_kwargs[key] = kwargs[key]
        term.compute(observable, **term_kwargs)

    # Sum all interaction terms
    total = sum(self.term)
    for attr in self.observable:
        setattr(self, attr, getattr(total, attr))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atooms.system.interaction.InteractionBase" href="#atooms.system.interaction.InteractionBase">InteractionBase</a></b></code>:
<ul class="hlist">
<li><code><a title="atooms.system.interaction.InteractionBase.variables" href="#atooms.system.interaction.InteractionBase.variables">variables</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="atooms.system.interaction.InteractionBase"><code class="flex name class">
<span>class <span class="ident">InteractionBase</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InteractionBase(object):

    def __init__(self):
        self.variables = {&#39;position&#39;: &#39;particle.position&#39;}
        &#34;&#34;&#34;
        A dictionary of variables needed to compute the interaction

        The keys must match the variable names in the
        `Interaction.compute()` interface, the fields must be
        canonicalizable variables accepted by `System.dump()`.

        It is possible to specify the required data type using the
        optionl colon syntax &lt;property&gt;[:&lt;dtype&gt;]. The dtype must a
        valid identifier for numpy array creation.
        &#34;&#34;&#34;
        # TODO: order is not a good variable, we should expand the syntax using [:order]
        self.order = &#39;F&#39;  # deprecated
        self.observable = [&#39;energy&#39;, &#39;forces&#39;, &#39;virial&#39;, &#39;stress&#39;, &#39;hessian&#39;]
        for observable in self.observable:
            setattr(self, observable, None)

    def __add__(self, other):
        total = Interaction()
        for attr in self.observable:
            if getattr(self, attr) is None and getattr(other, attr) is None:
                continue
            elif getattr(self, attr) is not None and getattr(other, attr) is not None:
                # Store the sum of the properties in the total interaction
                setattr(total, attr, getattr(self, attr) + getattr(other, attr))
            else:
                raise ValueError(&#39;attribute {} not set in {} or {}&#39;.format(attr,
                                                                           self,
                                                                           other))
        return total

    def __radd__(self, other):
        if other == 0:
            return self
        else:
            return self.__add__(other)

    def compute(self, observable, position):
        &#34;&#34;&#34;
        Compute an `observable` from this interaction

        Subclasses must adapt the interface so as to match the keys
        specified by the `Interaction.variables` dict.
        &#34;&#34;&#34;
        # Sanity checks
        assert observable in self.observable, \
            &#39;unsupported observable {}&#39;.format(observable)

        # Zeroing observables
        ndim, N = position.shape
        if observable == &#39;energy&#39;:
            self.energy = 0.0
        elif observable == &#39;forces&#39; or observable is None:
            self.energy = 0.0
            self.virial = 0.0
            self.forces = numpy.zeros_like(position)
        elif observable == &#39;stress&#39;:
            self.energy = 0.0
            self.virial = 0.0
            self.forces = numpy.zeros_like(position)
            self.stress = numpy.zeros(ndim, ndim)
        elif observable == &#39;hessian&#39;:
            self.hessian = numpy.zeros((ndim, N, ndim, N))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="atooms.system.interaction.Interaction" href="#atooms.system.interaction.Interaction">Interaction</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="atooms.system.interaction.InteractionBase.variables"><code class="name">var <span class="ident">variables</span></code></dt>
<dd>
<div class="desc"><p>A dictionary of variables needed to compute the interaction</p>
<p>The keys must match the variable names in the
<code><a title="atooms.system.interaction.Interaction.compute" href="#atooms.system.interaction.Interaction.compute">Interaction.compute()</a></code> interface, the fields must be
canonicalizable variables accepted by <code>System.dump()</code>.</p>
<p>It is possible to specify the required data type using the
optionl colon syntax <property>[:<dtype>]. The dtype must a
valid identifier for numpy array creation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atooms.system.interaction.InteractionBase.compute"><code class="name flex">
<span>def <span class="ident">compute</span></span>(<span>self, observable, position)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an <code>observable</code> from this interaction</p>
<p>Subclasses must adapt the interface so as to match the keys
specified by the <code><a title="atooms.system.interaction.Interaction.variables" href="#atooms.system.interaction.InteractionBase.variables">Interaction.variables</a></code> dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute(self, observable, position):
    &#34;&#34;&#34;
    Compute an `observable` from this interaction

    Subclasses must adapt the interface so as to match the keys
    specified by the `Interaction.variables` dict.
    &#34;&#34;&#34;
    # Sanity checks
    assert observable in self.observable, \
        &#39;unsupported observable {}&#39;.format(observable)

    # Zeroing observables
    ndim, N = position.shape
    if observable == &#39;energy&#39;:
        self.energy = 0.0
    elif observable == &#39;forces&#39; or observable is None:
        self.energy = 0.0
        self.virial = 0.0
        self.forces = numpy.zeros_like(position)
    elif observable == &#39;stress&#39;:
        self.energy = 0.0
        self.virial = 0.0
        self.forces = numpy.zeros_like(position)
        self.stress = numpy.zeros(ndim, ndim)
    elif observable == &#39;hessian&#39;:
        self.hessian = numpy.zeros((ndim, N, ndim, N))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atooms.system" href="index.html">atooms.system</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atooms.system.interaction.Interaction" href="#atooms.system.interaction.Interaction">Interaction</a></code></h4>
<ul class="">
<li><code><a title="atooms.system.interaction.Interaction.add" href="#atooms.system.interaction.Interaction.add">add</a></code></li>
<li><code><a title="atooms.system.interaction.Interaction.compute" href="#atooms.system.interaction.Interaction.compute">compute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atooms.system.interaction.InteractionBase" href="#atooms.system.interaction.InteractionBase">InteractionBase</a></code></h4>
<ul class="">
<li><code><a title="atooms.system.interaction.InteractionBase.compute" href="#atooms.system.interaction.InteractionBase.compute">compute</a></code></li>
<li><code><a title="atooms.system.interaction.InteractionBase.variables" href="#atooms.system.interaction.InteractionBase.variables">variables</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>