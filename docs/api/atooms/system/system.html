<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>atooms.system.system API documentation</title>
<meta name="description" content="The physical system at hand â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atooms.system.system</code></h1>
</header>
<section id="section-intro">
<p>The physical system at hand.</p>
<p>The system of interest in a classical atomistic simulations is
composed of interacting point particles, usually enclosed in a
simulation cell. The system may be in contact with a thermostat, a
barostat or a particle reservoir.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of atooms
# Copyright 2010-2017, Daniele Coslovich

&#34;&#34;&#34;
The physical system at hand.

The system of interest in a classical atomistic simulations is
composed of interacting point particles, usually enclosed in a
simulation cell. The system may be in contact with a thermostat, a
barostat or a particle reservoir.
&#34;&#34;&#34;

import copy
import numpy


class System(object):

    &#34;&#34;&#34;System class.&#34;&#34;&#34;

    def __init__(self, particle=None, cell=None, interaction=None,
                 thermostat=None, barostat=None, reservoir=None,
                 wall=None):
        if particle is None:
            particle = []
        self.particle = particle
        &#34;&#34;&#34;A list of `Particle` instances.&#34;&#34;&#34;
        self.interaction = interaction
        self.cell = cell
        self.thermostat = thermostat
        self.barostat = barostat
        self.reservoir = reservoir
        self.wall = wall
        # Internal data dictionary for array dumps
        self._data = None

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        # Note: when making a shallow copy the _data cache
        # may need to be cleared. We might set self._data to None here.
        return result

    def update(self, other, full=False, exclude=None, only=None):
        &#34;&#34;&#34;
        Update current system attributes in-place using the `other` System
        as source.

        The default behavior is to make deep copies only of all the
        `other` system attributes that are not None, i.e. which are
        set.

        To overwrite all attributes, even those set in `self` but not
        in `other`, use `full=True`.

        The lists `exclude` and `only` can be used to avoid updating
        some system attributes or to update only some system
        attributes, respectively.

        This method can be used by subclasses to deal with performace
        or memory dellocation issues.
        &#34;&#34;&#34;
        for key in other.__dict__:
            if exclude is not None or only is not None:
                if (exclude is not None and key not in exclude) or \
                   (only is not None and key in only):
                    self.__dict__[key] = copy.deepcopy(other.__dict__[key])
            else:
                if full or other.__dict__[key] is not None:
                    self.__dict__[key] = copy.deepcopy(other.__dict__[key])

        # Internal data dictionary for array dumps
        self._data = None

    @property
    def number_of_dimensions(self):
        &#34;&#34;&#34;
        Number of spatial dimensions, guessed from the length of
        `particle[0].position`.
        &#34;&#34;&#34;
        if len(self.particle) &gt; 0:
            return len(self.particle[0].position)
        elif self.cell is not None:
            return len(self.cell.side)
        else:
            return 0

    @property
    def distinct_species(self):
        &#34;&#34;&#34;Sorted list of distinct chemical species in the system.&#34;&#34;&#34;
        try:
            return list(sorted(set([p.species for p in self.particle])))
        except TypeError:
            return list(sorted(set([int(p.species) for p in self.particle])))

    @property
    def density(self):
        &#34;&#34;&#34;
        Density of the system.

        It `cell` is None, an estimate is given.
        &#34;&#34;&#34;
        if len(self.particle) == 0:
            return 0.0

        if self.cell is None:
            # Estimate density assuming V is the product of the
            # largest distances along each dimension
            volume = 1.0
            for axis in range(len(self.particle[0].position)):
                x_0 = min([p.position[axis] for p in self.particle])
                x_1 = max([p.position[axis] for p in self.particle])
                volume *= (x_1 - x_0)
            return len(self.particle) / volume
        else:
            return len(self.particle) / self.cell.volume

    @density.setter
    def density(self, rho):
        self.set_density(rho)

    def set_density(self, rho):
        &#34;&#34;&#34;Set the system density to `rho` by rescaling the coordinates.&#34;&#34;&#34;
        if self.cell is None:
            return ValueError(&#39;cannot compute density without a cell&#39;)
        factor = (self.density / rho)**(1./len(self.cell.side))
        for particle in self.particle:
            particle.position *= factor
        self.cell.side *= factor

    @property
    def packing_fraction(self):
        from math import pi
        return pi / 6 * sum([(2 * p.radius)**3 for p in self.particle]) / self.cell.volume

    @property
    def temperature(self):
        &#34;&#34;&#34;
        Kinetic temperature.
        &#34;&#34;&#34;
        # TODO: determine translational invariance via some additional attribute.
        if len(self.particle) &gt; 1:
            # Number of degrees of freddom is (N-1)*ndim
            ndof = (len(self.particle)-1) * self.number_of_dimensions
            return 2.0 / ndof * self.kinetic_energy()
        elif len(self.particle) == 1:
            # Pathological case
            return 2.0 / self.number_of_dimensions * self.kinetic_energy()
        else:
            # Empty particle list
            return 0.0

    @temperature.setter
    def temperature(self, T):
        self.set_temperature(T)

    def set_temperature(self, temperature):
        &#34;&#34;&#34;Reset velocities to a Maxwellian distribution with fixed CM.&#34;&#34;&#34;
        from .particle import fix_total_momentum
        T = temperature
        for p in self.particle:
            p.maxwellian(T)
        fix_total_momentum(self.particle)
        # After fixing the CM the temperature is not exactly the targeted one
        # Therefore we scale the velocities so as to get to the right T
        T_old = self.temperature
        if T_old &gt; 0.0:
            fac = (T/T_old)**0.5
            for p in self.particle:
                p.velocity *= fac

    def scale_velocities(self, factor):
        &#34;&#34;&#34;Scale particles&#39; velocities by `factor`.&#34;&#34;&#34;
        for p in self.particle:
            p.velocity *= factor

    def kinetic_energy(self, per_particle=False, normed=False):
        &#34;&#34;&#34;
        Return the total kinetic energy of the system.

        If `per_particle` or `normed` is `True`, return the kinetic
        energy per particle.
        &#34;&#34;&#34;
        ekin = sum([p.kinetic_energy for p in self.particle])
        if per_particle or normed:
            return ekin / len(self.particle)
        else:
            return ekin

    def compute_interaction(self, what=None):
        &#34;&#34;&#34;
        Compute interaction in the system
        &#34;&#34;&#34;
        if self.interaction is not None:
            kwargs = {}
            for variable, variable_to_dump in self.interaction.variables.items():
                # Get the optional data type
                dtype = None
                if &#39;:&#39; in variable_to_dump:
                    variable_to_dump, dtype = variable_to_dump.split(&#39;:&#39;)
                kwargs[variable] = self.dump(variable_to_dump,
                                             view=True, dtype=dtype,
                                             order=self.interaction.order)
            self.interaction.compute(what, **kwargs)

    def potential_energy(self, per_particle=False, normed=False, cache=False):
        &#34;&#34;&#34;
        Return the total potential energy of the system.

        If `per_particle` or `normed` is `True`, return the potential
        energy per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.energy is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle or normed:
                return self.interaction.energy / len(self.particle)
            else:
                return self.interaction.energy
        else:
            return 0.0

    def total_energy(self, per_particle=False, normed=None, cache=False):
        &#34;&#34;&#34;
        Return the total energy of the system.

        If `per_particle` or `normed` is `True`, return the total
        energy per particle.
        &#34;&#34;&#34;
        if normed is not None:
            per_particle = normed
        return self.potential_energy(per_particle, cache=cache) + self.kinetic_energy(per_particle)

    def force_norm(self, per_particle=True, cache=False):
        &#34;&#34;&#34;
        Return the norm of the force vector.

        If `per_particle` is `True`, return the force norm per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.forces is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle:
                return numpy.sum(self.interaction.forces**2)**0.5 / len(self.particle)
            else:
                return numpy.sum(self.interaction.forces**2)**0.5
        else:
            return 0.0

    def force_norm_square(self, per_particle=True, cache=False):
        &#34;&#34;&#34;
        Return the squared norm of the force vector.

        If `per_particle` is `True`, return the force squared norm per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.forces is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle:
                return numpy.sum(self.interaction.forces**2) / len(self.particle)
            else:
                return numpy.sum(self.interaction.forces**2)
        else:
            return 0.0

    def virial(self, per_particle=True, cache=False):
        &#34;&#34;&#34;
        Return the virial of the system.

        If `per_unit_volume` is `True`, return the virial per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.virial is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle:
                return self.interaction.virial / len(self.particle)
            else:
                return self.interaction.virial
        else:
            return 0.0

    @property
    def pressure(self):
        &#34;&#34;&#34;
        Return the pressure of the system.

        It assumes that `self.interaction` has already been computed.
        &#34;&#34;&#34;
        if self.thermostat:
            T = self.thermostat.temperature
        else:
            T = self.temperature
        return (len(self.particle) * T + self.interaction.virial / self.number_of_dimensions) / self.cell.volume

    def cm(self, what):
        &#34;&#34;&#34;General center-of-mass attribute.&#34;&#34;&#34;
        # It could be implemented in a more general and faster way via dumps
        # but one should pay attention to array ordering and views
        x = numpy.zeros_like(getattr(self.particle[0], what))
        mtot = 0.0
        for p in self.particle:
            x += getattr(p, what) * p.mass
            mtot += p.mass
        return x / mtot

    @property
    def cm_velocity(self):
        &#34;&#34;&#34;Center-of-mass velocity.&#34;&#34;&#34;
        return self.cm(&#39;velocity&#39;)

    @property
    def cm_position(self):
        &#34;&#34;&#34;Center-of-mass position.&#34;&#34;&#34;
        return self.cm(&#39;position&#39;)

    def fix_momentum(self):
        &#34;&#34;&#34;Subtract out the the center-of-mass motion.&#34;&#34;&#34;
        from .particle import fix_total_momentum
        fix_total_momentum(self.particle)

    def fold(self):
        &#34;&#34;&#34;Fold positions into central cell.&#34;&#34;&#34;
        for p in self.particle:
            p.fold(self.cell)

    def dump(self, what=None, order=&#39;C&#39;, dtype=None, view=False, clear=False, flat=False):
        &#34;&#34;&#34;
        Return a numpy array with system properties specified by `what`.

        `what` must be a string of the form `particle.&lt;attribute&gt;` or
        `cell.&lt;attribute&gt;`. Some aliases are allowed like:

        - `pos` (`particle.position`)
        - `vel` (`particle.velocity`)
        - `spe` (`particle.species`)

        If `what` is a System attribute, it is returned.

        If `view` is `True`, the requested particle property is set as
        a view on the corresponding portion of the dump array. This
        allows one to modify the dump array efficiently and keep the
        particle properties in sync. Numpy arrays must be modified
        in-place to keep everything in sync.

        If `clear` is True, a new view is created on the requested
        particle property.

        If `flat` is True, the resulting array is flatted following
        `order` using numpy.flatten().

        Particles&#39; coordinates are returned as (N, ndim) arrays if
        `order` is `C` or (ndim, N) arrays if `order` is `F`.

        Examples:
        --------
        These numpy arrays are element-wise identical

            #!python
            pos = system.dump(&#39;particle.position&#39;)
            pos = system.dump(&#39;position&#39;)
            pos = system.dump(&#39;pos&#39;)
        &#34;&#34;&#34;
        if isinstance(what, list):
            raise ValueError(&#39;list arguments to dump() are not supported, use dict comprehension instead&#39;)

        # If the attribute to dump is a plain System attribute, return it
        if what in self.__dict__:
            if view:
                return getattr(self, what)
            else:
                return copy.deepcopy(getattr(self, what))

        # Setup data cache dictionary for more complex attributes
        if self._data is None or clear:
            self._data = {}

        # Return immediately if we only want to clear the dump
        if clear and what is None:
            return

        # Accepts some aliases
        aliases = {
            &#39;box&#39;: &#39;cell.side&#39;,
            &#39;pos&#39;: &#39;particle.position&#39;,
            &#39;vel&#39;: &#39;particle.velocity&#39;,
            &#39;spe&#39;: &#39;particle.species&#39;,
            &#39;rad&#39;: &#39;particle.radius&#39;}
        if what in aliases:
            what = aliases[what]

        # We accept particle attributes
        if not what.startswith(&#39;particle&#39;) and not what.startswith(&#39;cell&#39;):
            what = &#39;particle.&#39; + what
        # Extract the requested attribute
        attr = what.split(&#39;.&#39;)[-1]

        # Make array of attributes
        if what.startswith(&#39;particle&#39;):
            if what in self._data and len(self.particle) == self._data[&#39;npart&#39;]:
                # Get the data in cache if it is present
                # and the number of particles has not changed.
                # Note: if particles are reassigned the cache will
                # not be updated. It can be fixed by keeping a list of ids
                # although testing it would bring a overhead.
                data = self._data[what]
                # If we are asking a flat copy we must not flatten the cached array
                if not view and flat:
                    data = copy.deepcopy(data).flatten(order=order)
            else:
                # We create a new array
                data = numpy.array([getattr(p, attr) for p in self.particle], dtype=dtype)
                # We transpose the array if F order is requested
                if order == &#39;F&#39;:
                    data = numpy.transpose(data)
                # If view is True, we set the particle property as a
                # view on the dump array. Pay attention of C / F order.
                # To check if particle properties and dump are associated:
                # numpy.may_share_memory(p[0].position, pos[:, 0])
                if view:
                    if not flat:
                        if order == &#39;C&#39;:
                            for i, p in enumerate(self.particle):
                                setattr(p, attr, data[i, ...])
                        if order == &#39;F&#39;:
                            for i, p in enumerate(self.particle):
                                setattr(p, attr, data[..., i])
                    else:
                        data = data.flatten(order=order)
                        shape = getattr(self.particle[0], attr).shape
                        if len(shape) == 2:
                            ndim = self.number_of_dimensions
                            for i, p in enumerate(self.particle):
                                setattr(p, attr, data[i*ndim: (i + 1)*ndim])
                else:
                    # We flatten the array if requested
                    if flat:
                        data = data.flatten(order=order)

        elif what.startswith(&#39;cell&#39;):
            data = numpy.array(getattr(self.cell, attr), dtype=dtype)
            if view:
                setattr(self.cell, attr, data)
        else:
            raise ValueError(&#39;Unknown attribute %s&#39; % what)

        if view:
            # Store data in local dict and keep track of the number of particles
            self._data[what] = data
            self._data[&#39;npart&#39;] = len(self.particle)
        else:
            data = copy.deepcopy(data)

        return data

    def __str__(self):
        txt = &#39;&#39;
        if self.particle:
            txt += &#39;system composed by {0} particles\n&#39;.format(len(self.particle))
        if self.cell:
            txt += &#39;enclosed in a {0.shape} box at number density rho={1:.6f}\n&#39;.format(self.cell, self.density)
        if self.wall:
            txt += &#39;surrounded by {} walls\n&#39;.format(len(self.wall))
        if self.thermostat:
            txt += &#39;in contact with a thermostat at T={0.temperature}\n&#39;.format(self.thermostat)
        if self.barostat:
            txt += &#39;in contact with a barostat at P={0.pressure}\n&#39;.format(self.barostat)
        if self.reservoir:
            txt += &#39;in contact with a reservoir at mu={0.chemical_potential}\n&#39;.format(self.reservoir)
        if self.interaction:
            txt += &#39;\n&#39;
            txt += str(self.interaction)
        return txt

    def show(self, backend=&#39;matplotlib&#39;, *args, **kwargs):
        from .visualize import show_ovito
        from .visualize import show_matplotlib
        from .visualize import show_3dmol

        if backend == &#39;matplotlib&#39;:
            _show = show_matplotlib
        elif backend == &#39;ovito&#39;:
            _show = show_ovito
        elif backend == &#39;3dmol&#39;:
            _show = show_3dmol
        else:
            raise ValueError(&#39;unknown backend for visualization&#39;)
        return _show(self.particle, self.cell, *args, **kwargs)

    @property
    def species_layout(self):
        &#34;&#34;&#34;
        Return species layout (A=alphabetical, C=C indexed, F=fortran indexed)
        &#34;&#34;&#34;
        try:
            species = [int(p.species) for p in self.particle]
        except ValueError:
            # The species cannot be converted to int, thus layout is
            # alphabetical
            # TODO: add periodic table layout &#39;P&#39;?
            layout = &#39;A&#39;
        else:
            min_sp = numpy.min(species)
            if min_sp == 0:
                layout = &#39;C&#39;
            elif min_sp == 1:
                layout = &#39;F&#39;
            else:
                raise ValueError(&#39;Numeric species should start from 0 or 1&#39;)
        return layout

    @species_layout.setter
    def species_layout(self, layout):
        &#34;&#34;&#34;
        Set species layout
        &#34;&#34;&#34;
        # Sanity checks
        layouts = [&#39;A&#39;, &#39;C&#39;, &#39;F&#39;]
        assert layout[0] in layouts, &#39;layout must be A, C or F (not {})&#39;.format(layout)

        # Do nothing if the layout is already ok
        current_layout = self.species_layout
        if layout == current_layout:
            return

        # Convert to new layout
        import string
        if layout[0] == &#39;A&#39;:
            # We get the index of the species map:
            # - if current layout is F (min_sp=1), we subtract one.
            # - if current layout is C (min_sp=0), we do nothing
            species = [int(p.species) for p in self.particle]
            min_sp = numpy.min(species)
            species_map = string.ascii_uppercase
            for p in self.particle:
                p.species = species_map[int(p.species) - min_sp]
        else:
            # Output layout is numerical (C or F)
            offset = 1 if layout[0] == &#39;F&#39; else 0
            # Note that distinct_species is sorted alphabetically
            species_list = self.distinct_species
            if current_layout[0] == &#39;A&#39;:
                for p in self.particle:
                    p.species = str(species_list.index(p.species) + offset)
            else:
                # If layout=C, current_layout is F and we subtract 2*offset-1=-1
                # If layout=F, current_layout is C and we add 2*offset-1=+1
                for p in self.particle:
                    p.species = str(int(p.species) + 2*offset - 1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atooms.system.system.System"><code class="flex name class">
<span>class <span class="ident">System</span></span>
<span>(</span><span>particle=None, cell=None, interaction=None, thermostat=None, barostat=None, reservoir=None, wall=None)</span>
</code></dt>
<dd>
<div class="desc"><p>System class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class System(object):

    &#34;&#34;&#34;System class.&#34;&#34;&#34;

    def __init__(self, particle=None, cell=None, interaction=None,
                 thermostat=None, barostat=None, reservoir=None,
                 wall=None):
        if particle is None:
            particle = []
        self.particle = particle
        &#34;&#34;&#34;A list of `Particle` instances.&#34;&#34;&#34;
        self.interaction = interaction
        self.cell = cell
        self.thermostat = thermostat
        self.barostat = barostat
        self.reservoir = reservoir
        self.wall = wall
        # Internal data dictionary for array dumps
        self._data = None

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        # Note: when making a shallow copy the _data cache
        # may need to be cleared. We might set self._data to None here.
        return result

    def update(self, other, full=False, exclude=None, only=None):
        &#34;&#34;&#34;
        Update current system attributes in-place using the `other` System
        as source.

        The default behavior is to make deep copies only of all the
        `other` system attributes that are not None, i.e. which are
        set.

        To overwrite all attributes, even those set in `self` but not
        in `other`, use `full=True`.

        The lists `exclude` and `only` can be used to avoid updating
        some system attributes or to update only some system
        attributes, respectively.

        This method can be used by subclasses to deal with performace
        or memory dellocation issues.
        &#34;&#34;&#34;
        for key in other.__dict__:
            if exclude is not None or only is not None:
                if (exclude is not None and key not in exclude) or \
                   (only is not None and key in only):
                    self.__dict__[key] = copy.deepcopy(other.__dict__[key])
            else:
                if full or other.__dict__[key] is not None:
                    self.__dict__[key] = copy.deepcopy(other.__dict__[key])

        # Internal data dictionary for array dumps
        self._data = None

    @property
    def number_of_dimensions(self):
        &#34;&#34;&#34;
        Number of spatial dimensions, guessed from the length of
        `particle[0].position`.
        &#34;&#34;&#34;
        if len(self.particle) &gt; 0:
            return len(self.particle[0].position)
        elif self.cell is not None:
            return len(self.cell.side)
        else:
            return 0

    @property
    def distinct_species(self):
        &#34;&#34;&#34;Sorted list of distinct chemical species in the system.&#34;&#34;&#34;
        try:
            return list(sorted(set([p.species for p in self.particle])))
        except TypeError:
            return list(sorted(set([int(p.species) for p in self.particle])))

    @property
    def density(self):
        &#34;&#34;&#34;
        Density of the system.

        It `cell` is None, an estimate is given.
        &#34;&#34;&#34;
        if len(self.particle) == 0:
            return 0.0

        if self.cell is None:
            # Estimate density assuming V is the product of the
            # largest distances along each dimension
            volume = 1.0
            for axis in range(len(self.particle[0].position)):
                x_0 = min([p.position[axis] for p in self.particle])
                x_1 = max([p.position[axis] for p in self.particle])
                volume *= (x_1 - x_0)
            return len(self.particle) / volume
        else:
            return len(self.particle) / self.cell.volume

    @density.setter
    def density(self, rho):
        self.set_density(rho)

    def set_density(self, rho):
        &#34;&#34;&#34;Set the system density to `rho` by rescaling the coordinates.&#34;&#34;&#34;
        if self.cell is None:
            return ValueError(&#39;cannot compute density without a cell&#39;)
        factor = (self.density / rho)**(1./len(self.cell.side))
        for particle in self.particle:
            particle.position *= factor
        self.cell.side *= factor

    @property
    def packing_fraction(self):
        from math import pi
        return pi / 6 * sum([(2 * p.radius)**3 for p in self.particle]) / self.cell.volume

    @property
    def temperature(self):
        &#34;&#34;&#34;
        Kinetic temperature.
        &#34;&#34;&#34;
        # TODO: determine translational invariance via some additional attribute.
        if len(self.particle) &gt; 1:
            # Number of degrees of freddom is (N-1)*ndim
            ndof = (len(self.particle)-1) * self.number_of_dimensions
            return 2.0 / ndof * self.kinetic_energy()
        elif len(self.particle) == 1:
            # Pathological case
            return 2.0 / self.number_of_dimensions * self.kinetic_energy()
        else:
            # Empty particle list
            return 0.0

    @temperature.setter
    def temperature(self, T):
        self.set_temperature(T)

    def set_temperature(self, temperature):
        &#34;&#34;&#34;Reset velocities to a Maxwellian distribution with fixed CM.&#34;&#34;&#34;
        from .particle import fix_total_momentum
        T = temperature
        for p in self.particle:
            p.maxwellian(T)
        fix_total_momentum(self.particle)
        # After fixing the CM the temperature is not exactly the targeted one
        # Therefore we scale the velocities so as to get to the right T
        T_old = self.temperature
        if T_old &gt; 0.0:
            fac = (T/T_old)**0.5
            for p in self.particle:
                p.velocity *= fac

    def scale_velocities(self, factor):
        &#34;&#34;&#34;Scale particles&#39; velocities by `factor`.&#34;&#34;&#34;
        for p in self.particle:
            p.velocity *= factor

    def kinetic_energy(self, per_particle=False, normed=False):
        &#34;&#34;&#34;
        Return the total kinetic energy of the system.

        If `per_particle` or `normed` is `True`, return the kinetic
        energy per particle.
        &#34;&#34;&#34;
        ekin = sum([p.kinetic_energy for p in self.particle])
        if per_particle or normed:
            return ekin / len(self.particle)
        else:
            return ekin

    def compute_interaction(self, what=None):
        &#34;&#34;&#34;
        Compute interaction in the system
        &#34;&#34;&#34;
        if self.interaction is not None:
            kwargs = {}
            for variable, variable_to_dump in self.interaction.variables.items():
                # Get the optional data type
                dtype = None
                if &#39;:&#39; in variable_to_dump:
                    variable_to_dump, dtype = variable_to_dump.split(&#39;:&#39;)
                kwargs[variable] = self.dump(variable_to_dump,
                                             view=True, dtype=dtype,
                                             order=self.interaction.order)
            self.interaction.compute(what, **kwargs)

    def potential_energy(self, per_particle=False, normed=False, cache=False):
        &#34;&#34;&#34;
        Return the total potential energy of the system.

        If `per_particle` or `normed` is `True`, return the potential
        energy per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.energy is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle or normed:
                return self.interaction.energy / len(self.particle)
            else:
                return self.interaction.energy
        else:
            return 0.0

    def total_energy(self, per_particle=False, normed=None, cache=False):
        &#34;&#34;&#34;
        Return the total energy of the system.

        If `per_particle` or `normed` is `True`, return the total
        energy per particle.
        &#34;&#34;&#34;
        if normed is not None:
            per_particle = normed
        return self.potential_energy(per_particle, cache=cache) + self.kinetic_energy(per_particle)

    def force_norm(self, per_particle=True, cache=False):
        &#34;&#34;&#34;
        Return the norm of the force vector.

        If `per_particle` is `True`, return the force norm per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.forces is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle:
                return numpy.sum(self.interaction.forces**2)**0.5 / len(self.particle)
            else:
                return numpy.sum(self.interaction.forces**2)**0.5
        else:
            return 0.0

    def force_norm_square(self, per_particle=True, cache=False):
        &#34;&#34;&#34;
        Return the squared norm of the force vector.

        If `per_particle` is `True`, return the force squared norm per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.forces is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle:
                return numpy.sum(self.interaction.forces**2) / len(self.particle)
            else:
                return numpy.sum(self.interaction.forces**2)
        else:
            return 0.0

    def virial(self, per_particle=True, cache=False):
        &#34;&#34;&#34;
        Return the virial of the system.

        If `per_unit_volume` is `True`, return the virial per particle.
        &#34;&#34;&#34;
        if self.interaction is not None:
            if not cache or self.interaction.virial is None:
                self.compute_interaction(&#39;forces&#39;)
            if per_particle:
                return self.interaction.virial / len(self.particle)
            else:
                return self.interaction.virial
        else:
            return 0.0

    @property
    def pressure(self):
        &#34;&#34;&#34;
        Return the pressure of the system.

        It assumes that `self.interaction` has already been computed.
        &#34;&#34;&#34;
        if self.thermostat:
            T = self.thermostat.temperature
        else:
            T = self.temperature
        return (len(self.particle) * T + self.interaction.virial / self.number_of_dimensions) / self.cell.volume

    def cm(self, what):
        &#34;&#34;&#34;General center-of-mass attribute.&#34;&#34;&#34;
        # It could be implemented in a more general and faster way via dumps
        # but one should pay attention to array ordering and views
        x = numpy.zeros_like(getattr(self.particle[0], what))
        mtot = 0.0
        for p in self.particle:
            x += getattr(p, what) * p.mass
            mtot += p.mass
        return x / mtot

    @property
    def cm_velocity(self):
        &#34;&#34;&#34;Center-of-mass velocity.&#34;&#34;&#34;
        return self.cm(&#39;velocity&#39;)

    @property
    def cm_position(self):
        &#34;&#34;&#34;Center-of-mass position.&#34;&#34;&#34;
        return self.cm(&#39;position&#39;)

    def fix_momentum(self):
        &#34;&#34;&#34;Subtract out the the center-of-mass motion.&#34;&#34;&#34;
        from .particle import fix_total_momentum
        fix_total_momentum(self.particle)

    def fold(self):
        &#34;&#34;&#34;Fold positions into central cell.&#34;&#34;&#34;
        for p in self.particle:
            p.fold(self.cell)

    def dump(self, what=None, order=&#39;C&#39;, dtype=None, view=False, clear=False, flat=False):
        &#34;&#34;&#34;
        Return a numpy array with system properties specified by `what`.

        `what` must be a string of the form `particle.&lt;attribute&gt;` or
        `cell.&lt;attribute&gt;`. Some aliases are allowed like:

        - `pos` (`particle.position`)
        - `vel` (`particle.velocity`)
        - `spe` (`particle.species`)

        If `what` is a System attribute, it is returned.

        If `view` is `True`, the requested particle property is set as
        a view on the corresponding portion of the dump array. This
        allows one to modify the dump array efficiently and keep the
        particle properties in sync. Numpy arrays must be modified
        in-place to keep everything in sync.

        If `clear` is True, a new view is created on the requested
        particle property.

        If `flat` is True, the resulting array is flatted following
        `order` using numpy.flatten().

        Particles&#39; coordinates are returned as (N, ndim) arrays if
        `order` is `C` or (ndim, N) arrays if `order` is `F`.

        Examples:
        --------
        These numpy arrays are element-wise identical

            #!python
            pos = system.dump(&#39;particle.position&#39;)
            pos = system.dump(&#39;position&#39;)
            pos = system.dump(&#39;pos&#39;)
        &#34;&#34;&#34;
        if isinstance(what, list):
            raise ValueError(&#39;list arguments to dump() are not supported, use dict comprehension instead&#39;)

        # If the attribute to dump is a plain System attribute, return it
        if what in self.__dict__:
            if view:
                return getattr(self, what)
            else:
                return copy.deepcopy(getattr(self, what))

        # Setup data cache dictionary for more complex attributes
        if self._data is None or clear:
            self._data = {}

        # Return immediately if we only want to clear the dump
        if clear and what is None:
            return

        # Accepts some aliases
        aliases = {
            &#39;box&#39;: &#39;cell.side&#39;,
            &#39;pos&#39;: &#39;particle.position&#39;,
            &#39;vel&#39;: &#39;particle.velocity&#39;,
            &#39;spe&#39;: &#39;particle.species&#39;,
            &#39;rad&#39;: &#39;particle.radius&#39;}
        if what in aliases:
            what = aliases[what]

        # We accept particle attributes
        if not what.startswith(&#39;particle&#39;) and not what.startswith(&#39;cell&#39;):
            what = &#39;particle.&#39; + what
        # Extract the requested attribute
        attr = what.split(&#39;.&#39;)[-1]

        # Make array of attributes
        if what.startswith(&#39;particle&#39;):
            if what in self._data and len(self.particle) == self._data[&#39;npart&#39;]:
                # Get the data in cache if it is present
                # and the number of particles has not changed.
                # Note: if particles are reassigned the cache will
                # not be updated. It can be fixed by keeping a list of ids
                # although testing it would bring a overhead.
                data = self._data[what]
                # If we are asking a flat copy we must not flatten the cached array
                if not view and flat:
                    data = copy.deepcopy(data).flatten(order=order)
            else:
                # We create a new array
                data = numpy.array([getattr(p, attr) for p in self.particle], dtype=dtype)
                # We transpose the array if F order is requested
                if order == &#39;F&#39;:
                    data = numpy.transpose(data)
                # If view is True, we set the particle property as a
                # view on the dump array. Pay attention of C / F order.
                # To check if particle properties and dump are associated:
                # numpy.may_share_memory(p[0].position, pos[:, 0])
                if view:
                    if not flat:
                        if order == &#39;C&#39;:
                            for i, p in enumerate(self.particle):
                                setattr(p, attr, data[i, ...])
                        if order == &#39;F&#39;:
                            for i, p in enumerate(self.particle):
                                setattr(p, attr, data[..., i])
                    else:
                        data = data.flatten(order=order)
                        shape = getattr(self.particle[0], attr).shape
                        if len(shape) == 2:
                            ndim = self.number_of_dimensions
                            for i, p in enumerate(self.particle):
                                setattr(p, attr, data[i*ndim: (i + 1)*ndim])
                else:
                    # We flatten the array if requested
                    if flat:
                        data = data.flatten(order=order)

        elif what.startswith(&#39;cell&#39;):
            data = numpy.array(getattr(self.cell, attr), dtype=dtype)
            if view:
                setattr(self.cell, attr, data)
        else:
            raise ValueError(&#39;Unknown attribute %s&#39; % what)

        if view:
            # Store data in local dict and keep track of the number of particles
            self._data[what] = data
            self._data[&#39;npart&#39;] = len(self.particle)
        else:
            data = copy.deepcopy(data)

        return data

    def __str__(self):
        txt = &#39;&#39;
        if self.particle:
            txt += &#39;system composed by {0} particles\n&#39;.format(len(self.particle))
        if self.cell:
            txt += &#39;enclosed in a {0.shape} box at number density rho={1:.6f}\n&#39;.format(self.cell, self.density)
        if self.wall:
            txt += &#39;surrounded by {} walls\n&#39;.format(len(self.wall))
        if self.thermostat:
            txt += &#39;in contact with a thermostat at T={0.temperature}\n&#39;.format(self.thermostat)
        if self.barostat:
            txt += &#39;in contact with a barostat at P={0.pressure}\n&#39;.format(self.barostat)
        if self.reservoir:
            txt += &#39;in contact with a reservoir at mu={0.chemical_potential}\n&#39;.format(self.reservoir)
        if self.interaction:
            txt += &#39;\n&#39;
            txt += str(self.interaction)
        return txt

    def show(self, backend=&#39;matplotlib&#39;, *args, **kwargs):
        from .visualize import show_ovito
        from .visualize import show_matplotlib
        from .visualize import show_3dmol

        if backend == &#39;matplotlib&#39;:
            _show = show_matplotlib
        elif backend == &#39;ovito&#39;:
            _show = show_ovito
        elif backend == &#39;3dmol&#39;:
            _show = show_3dmol
        else:
            raise ValueError(&#39;unknown backend for visualization&#39;)
        return _show(self.particle, self.cell, *args, **kwargs)

    @property
    def species_layout(self):
        &#34;&#34;&#34;
        Return species layout (A=alphabetical, C=C indexed, F=fortran indexed)
        &#34;&#34;&#34;
        try:
            species = [int(p.species) for p in self.particle]
        except ValueError:
            # The species cannot be converted to int, thus layout is
            # alphabetical
            # TODO: add periodic table layout &#39;P&#39;?
            layout = &#39;A&#39;
        else:
            min_sp = numpy.min(species)
            if min_sp == 0:
                layout = &#39;C&#39;
            elif min_sp == 1:
                layout = &#39;F&#39;
            else:
                raise ValueError(&#39;Numeric species should start from 0 or 1&#39;)
        return layout

    @species_layout.setter
    def species_layout(self, layout):
        &#34;&#34;&#34;
        Set species layout
        &#34;&#34;&#34;
        # Sanity checks
        layouts = [&#39;A&#39;, &#39;C&#39;, &#39;F&#39;]
        assert layout[0] in layouts, &#39;layout must be A, C or F (not {})&#39;.format(layout)

        # Do nothing if the layout is already ok
        current_layout = self.species_layout
        if layout == current_layout:
            return

        # Convert to new layout
        import string
        if layout[0] == &#39;A&#39;:
            # We get the index of the species map:
            # - if current layout is F (min_sp=1), we subtract one.
            # - if current layout is C (min_sp=0), we do nothing
            species = [int(p.species) for p in self.particle]
            min_sp = numpy.min(species)
            species_map = string.ascii_uppercase
            for p in self.particle:
                p.species = species_map[int(p.species) - min_sp]
        else:
            # Output layout is numerical (C or F)
            offset = 1 if layout[0] == &#39;F&#39; else 0
            # Note that distinct_species is sorted alphabetically
            species_list = self.distinct_species
            if current_layout[0] == &#39;A&#39;:
                for p in self.particle:
                    p.species = str(species_list.index(p.species) + offset)
            else:
                # If layout=C, current_layout is F and we subtract 2*offset-1=-1
                # If layout=F, current_layout is C and we add 2*offset-1=+1
                for p in self.particle:
                    p.species = str(int(p.species) + 2*offset - 1)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="atooms.system.system.System.cm_position"><code class="name">var <span class="ident">cm_position</span></code></dt>
<dd>
<div class="desc"><p>Center-of-mass position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cm_position(self):
    &#34;&#34;&#34;Center-of-mass position.&#34;&#34;&#34;
    return self.cm(&#39;position&#39;)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.cm_velocity"><code class="name">var <span class="ident">cm_velocity</span></code></dt>
<dd>
<div class="desc"><p>Center-of-mass velocity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cm_velocity(self):
    &#34;&#34;&#34;Center-of-mass velocity.&#34;&#34;&#34;
    return self.cm(&#39;velocity&#39;)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.density"><code class="name">var <span class="ident">density</span></code></dt>
<dd>
<div class="desc"><p>Density of the system.</p>
<p>It <code>cell</code> is None, an estimate is given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def density(self):
    &#34;&#34;&#34;
    Density of the system.

    It `cell` is None, an estimate is given.
    &#34;&#34;&#34;
    if len(self.particle) == 0:
        return 0.0

    if self.cell is None:
        # Estimate density assuming V is the product of the
        # largest distances along each dimension
        volume = 1.0
        for axis in range(len(self.particle[0].position)):
            x_0 = min([p.position[axis] for p in self.particle])
            x_1 = max([p.position[axis] for p in self.particle])
            volume *= (x_1 - x_0)
        return len(self.particle) / volume
    else:
        return len(self.particle) / self.cell.volume</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.distinct_species"><code class="name">var <span class="ident">distinct_species</span></code></dt>
<dd>
<div class="desc"><p>Sorted list of distinct chemical species in the system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distinct_species(self):
    &#34;&#34;&#34;Sorted list of distinct chemical species in the system.&#34;&#34;&#34;
    try:
        return list(sorted(set([p.species for p in self.particle])))
    except TypeError:
        return list(sorted(set([int(p.species) for p in self.particle])))</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.number_of_dimensions"><code class="name">var <span class="ident">number_of_dimensions</span></code></dt>
<dd>
<div class="desc"><p>Number of spatial dimensions, guessed from the length of
<code>particle[0].position</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_of_dimensions(self):
    &#34;&#34;&#34;
    Number of spatial dimensions, guessed from the length of
    `particle[0].position`.
    &#34;&#34;&#34;
    if len(self.particle) &gt; 0:
        return len(self.particle[0].position)
    elif self.cell is not None:
        return len(self.cell.side)
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.packing_fraction"><code class="name">var <span class="ident">packing_fraction</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def packing_fraction(self):
    from math import pi
    return pi / 6 * sum([(2 * p.radius)**3 for p in self.particle]) / self.cell.volume</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.particle"><code class="name">var <span class="ident">particle</span></code></dt>
<dd>
<div class="desc"><p>A list of <code>Particle</code> instances.</p></div>
</dd>
<dt id="atooms.system.system.System.pressure"><code class="name">var <span class="ident">pressure</span></code></dt>
<dd>
<div class="desc"><p>Return the pressure of the system.</p>
<p>It assumes that <code>self.interaction</code> has already been computed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pressure(self):
    &#34;&#34;&#34;
    Return the pressure of the system.

    It assumes that `self.interaction` has already been computed.
    &#34;&#34;&#34;
    if self.thermostat:
        T = self.thermostat.temperature
    else:
        T = self.temperature
    return (len(self.particle) * T + self.interaction.virial / self.number_of_dimensions) / self.cell.volume</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.species_layout"><code class="name">var <span class="ident">species_layout</span></code></dt>
<dd>
<div class="desc"><p>Return species layout (A=alphabetical, C=C indexed, F=fortran indexed)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def species_layout(self):
    &#34;&#34;&#34;
    Return species layout (A=alphabetical, C=C indexed, F=fortran indexed)
    &#34;&#34;&#34;
    try:
        species = [int(p.species) for p in self.particle]
    except ValueError:
        # The species cannot be converted to int, thus layout is
        # alphabetical
        # TODO: add periodic table layout &#39;P&#39;?
        layout = &#39;A&#39;
    else:
        min_sp = numpy.min(species)
        if min_sp == 0:
            layout = &#39;C&#39;
        elif min_sp == 1:
            layout = &#39;F&#39;
        else:
            raise ValueError(&#39;Numeric species should start from 0 or 1&#39;)
    return layout</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.temperature"><code class="name">var <span class="ident">temperature</span></code></dt>
<dd>
<div class="desc"><p>Kinetic temperature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def temperature(self):
    &#34;&#34;&#34;
    Kinetic temperature.
    &#34;&#34;&#34;
    # TODO: determine translational invariance via some additional attribute.
    if len(self.particle) &gt; 1:
        # Number of degrees of freddom is (N-1)*ndim
        ndof = (len(self.particle)-1) * self.number_of_dimensions
        return 2.0 / ndof * self.kinetic_energy()
    elif len(self.particle) == 1:
        # Pathological case
        return 2.0 / self.number_of_dimensions * self.kinetic_energy()
    else:
        # Empty particle list
        return 0.0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atooms.system.system.System.cm"><code class="name flex">
<span>def <span class="ident">cm</span></span>(<span>self, what)</span>
</code></dt>
<dd>
<div class="desc"><p>General center-of-mass attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cm(self, what):
    &#34;&#34;&#34;General center-of-mass attribute.&#34;&#34;&#34;
    # It could be implemented in a more general and faster way via dumps
    # but one should pay attention to array ordering and views
    x = numpy.zeros_like(getattr(self.particle[0], what))
    mtot = 0.0
    for p in self.particle:
        x += getattr(p, what) * p.mass
        mtot += p.mass
    return x / mtot</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.compute_interaction"><code class="name flex">
<span>def <span class="ident">compute_interaction</span></span>(<span>self, what=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute interaction in the system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_interaction(self, what=None):
    &#34;&#34;&#34;
    Compute interaction in the system
    &#34;&#34;&#34;
    if self.interaction is not None:
        kwargs = {}
        for variable, variable_to_dump in self.interaction.variables.items():
            # Get the optional data type
            dtype = None
            if &#39;:&#39; in variable_to_dump:
                variable_to_dump, dtype = variable_to_dump.split(&#39;:&#39;)
            kwargs[variable] = self.dump(variable_to_dump,
                                         view=True, dtype=dtype,
                                         order=self.interaction.order)
        self.interaction.compute(what, **kwargs)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self, what=None, order='C', dtype=None, view=False, clear=False, flat=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a numpy array with system properties specified by <code>what</code>.</p>
<p><code>what</code> must be a string of the form <code>particle.&lt;attribute&gt;</code> or
<code>cell.&lt;attribute&gt;</code>. Some aliases are allowed like:</p>
<ul>
<li><code>pos</code> (<code>particle.position</code>)</li>
<li><code>vel</code> (<code>particle.velocity</code>)</li>
<li><code>spe</code> (<code>particle.species</code>)</li>
</ul>
<p>If <code>what</code> is a System attribute, it is returned.</p>
<p>If <code>view</code> is <code>True</code>, the requested particle property is set as
a view on the corresponding portion of the dump array. This
allows one to modify the dump array efficiently and keep the
particle properties in sync. Numpy arrays must be modified
in-place to keep everything in sync.</p>
<p>If <code>clear</code> is True, a new view is created on the requested
particle property.</p>
<p>If <code>flat</code> is True, the resulting array is flatted following
<code>order</code> using numpy.flatten().</p>
<p>Particles' coordinates are returned as (N, ndim) arrays if
<code>order</code> is <code>C</code> or (ndim, N) arrays if <code>order</code> is <code>F</code>.</p>
<h2 id="examples">Examples:</h2>
<p>These numpy arrays are element-wise identical</p>
<pre><code>#!python
pos = system.dump('particle.position')
pos = system.dump('position')
pos = system.dump('pos')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self, what=None, order=&#39;C&#39;, dtype=None, view=False, clear=False, flat=False):
    &#34;&#34;&#34;
    Return a numpy array with system properties specified by `what`.

    `what` must be a string of the form `particle.&lt;attribute&gt;` or
    `cell.&lt;attribute&gt;`. Some aliases are allowed like:

    - `pos` (`particle.position`)
    - `vel` (`particle.velocity`)
    - `spe` (`particle.species`)

    If `what` is a System attribute, it is returned.

    If `view` is `True`, the requested particle property is set as
    a view on the corresponding portion of the dump array. This
    allows one to modify the dump array efficiently and keep the
    particle properties in sync. Numpy arrays must be modified
    in-place to keep everything in sync.

    If `clear` is True, a new view is created on the requested
    particle property.

    If `flat` is True, the resulting array is flatted following
    `order` using numpy.flatten().

    Particles&#39; coordinates are returned as (N, ndim) arrays if
    `order` is `C` or (ndim, N) arrays if `order` is `F`.

    Examples:
    --------
    These numpy arrays are element-wise identical

        #!python
        pos = system.dump(&#39;particle.position&#39;)
        pos = system.dump(&#39;position&#39;)
        pos = system.dump(&#39;pos&#39;)
    &#34;&#34;&#34;
    if isinstance(what, list):
        raise ValueError(&#39;list arguments to dump() are not supported, use dict comprehension instead&#39;)

    # If the attribute to dump is a plain System attribute, return it
    if what in self.__dict__:
        if view:
            return getattr(self, what)
        else:
            return copy.deepcopy(getattr(self, what))

    # Setup data cache dictionary for more complex attributes
    if self._data is None or clear:
        self._data = {}

    # Return immediately if we only want to clear the dump
    if clear and what is None:
        return

    # Accepts some aliases
    aliases = {
        &#39;box&#39;: &#39;cell.side&#39;,
        &#39;pos&#39;: &#39;particle.position&#39;,
        &#39;vel&#39;: &#39;particle.velocity&#39;,
        &#39;spe&#39;: &#39;particle.species&#39;,
        &#39;rad&#39;: &#39;particle.radius&#39;}
    if what in aliases:
        what = aliases[what]

    # We accept particle attributes
    if not what.startswith(&#39;particle&#39;) and not what.startswith(&#39;cell&#39;):
        what = &#39;particle.&#39; + what
    # Extract the requested attribute
    attr = what.split(&#39;.&#39;)[-1]

    # Make array of attributes
    if what.startswith(&#39;particle&#39;):
        if what in self._data and len(self.particle) == self._data[&#39;npart&#39;]:
            # Get the data in cache if it is present
            # and the number of particles has not changed.
            # Note: if particles are reassigned the cache will
            # not be updated. It can be fixed by keeping a list of ids
            # although testing it would bring a overhead.
            data = self._data[what]
            # If we are asking a flat copy we must not flatten the cached array
            if not view and flat:
                data = copy.deepcopy(data).flatten(order=order)
        else:
            # We create a new array
            data = numpy.array([getattr(p, attr) for p in self.particle], dtype=dtype)
            # We transpose the array if F order is requested
            if order == &#39;F&#39;:
                data = numpy.transpose(data)
            # If view is True, we set the particle property as a
            # view on the dump array. Pay attention of C / F order.
            # To check if particle properties and dump are associated:
            # numpy.may_share_memory(p[0].position, pos[:, 0])
            if view:
                if not flat:
                    if order == &#39;C&#39;:
                        for i, p in enumerate(self.particle):
                            setattr(p, attr, data[i, ...])
                    if order == &#39;F&#39;:
                        for i, p in enumerate(self.particle):
                            setattr(p, attr, data[..., i])
                else:
                    data = data.flatten(order=order)
                    shape = getattr(self.particle[0], attr).shape
                    if len(shape) == 2:
                        ndim = self.number_of_dimensions
                        for i, p in enumerate(self.particle):
                            setattr(p, attr, data[i*ndim: (i + 1)*ndim])
            else:
                # We flatten the array if requested
                if flat:
                    data = data.flatten(order=order)

    elif what.startswith(&#39;cell&#39;):
        data = numpy.array(getattr(self.cell, attr), dtype=dtype)
        if view:
            setattr(self.cell, attr, data)
    else:
        raise ValueError(&#39;Unknown attribute %s&#39; % what)

    if view:
        # Store data in local dict and keep track of the number of particles
        self._data[what] = data
        self._data[&#39;npart&#39;] = len(self.particle)
    else:
        data = copy.deepcopy(data)

    return data</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.fix_momentum"><code class="name flex">
<span>def <span class="ident">fix_momentum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subtract out the the center-of-mass motion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_momentum(self):
    &#34;&#34;&#34;Subtract out the the center-of-mass motion.&#34;&#34;&#34;
    from .particle import fix_total_momentum
    fix_total_momentum(self.particle)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fold positions into central cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self):
    &#34;&#34;&#34;Fold positions into central cell.&#34;&#34;&#34;
    for p in self.particle:
        p.fold(self.cell)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.force_norm"><code class="name flex">
<span>def <span class="ident">force_norm</span></span>(<span>self, per_particle=True, cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the norm of the force vector.</p>
<p>If <code>per_particle</code> is <code>True</code>, return the force norm per particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_norm(self, per_particle=True, cache=False):
    &#34;&#34;&#34;
    Return the norm of the force vector.

    If `per_particle` is `True`, return the force norm per particle.
    &#34;&#34;&#34;
    if self.interaction is not None:
        if not cache or self.interaction.forces is None:
            self.compute_interaction(&#39;forces&#39;)
        if per_particle:
            return numpy.sum(self.interaction.forces**2)**0.5 / len(self.particle)
        else:
            return numpy.sum(self.interaction.forces**2)**0.5
    else:
        return 0.0</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.force_norm_square"><code class="name flex">
<span>def <span class="ident">force_norm_square</span></span>(<span>self, per_particle=True, cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the squared norm of the force vector.</p>
<p>If <code>per_particle</code> is <code>True</code>, return the force squared norm per particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_norm_square(self, per_particle=True, cache=False):
    &#34;&#34;&#34;
    Return the squared norm of the force vector.

    If `per_particle` is `True`, return the force squared norm per particle.
    &#34;&#34;&#34;
    if self.interaction is not None:
        if not cache or self.interaction.forces is None:
            self.compute_interaction(&#39;forces&#39;)
        if per_particle:
            return numpy.sum(self.interaction.forces**2) / len(self.particle)
        else:
            return numpy.sum(self.interaction.forces**2)
    else:
        return 0.0</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.kinetic_energy"><code class="name flex">
<span>def <span class="ident">kinetic_energy</span></span>(<span>self, per_particle=False, normed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the total kinetic energy of the system.</p>
<p>If <code>per_particle</code> or <code>normed</code> is <code>True</code>, return the kinetic
energy per particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kinetic_energy(self, per_particle=False, normed=False):
    &#34;&#34;&#34;
    Return the total kinetic energy of the system.

    If `per_particle` or `normed` is `True`, return the kinetic
    energy per particle.
    &#34;&#34;&#34;
    ekin = sum([p.kinetic_energy for p in self.particle])
    if per_particle or normed:
        return ekin / len(self.particle)
    else:
        return ekin</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.potential_energy"><code class="name flex">
<span>def <span class="ident">potential_energy</span></span>(<span>self, per_particle=False, normed=False, cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the total potential energy of the system.</p>
<p>If <code>per_particle</code> or <code>normed</code> is <code>True</code>, return the potential
energy per particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def potential_energy(self, per_particle=False, normed=False, cache=False):
    &#34;&#34;&#34;
    Return the total potential energy of the system.

    If `per_particle` or `normed` is `True`, return the potential
    energy per particle.
    &#34;&#34;&#34;
    if self.interaction is not None:
        if not cache or self.interaction.energy is None:
            self.compute_interaction(&#39;forces&#39;)
        if per_particle or normed:
            return self.interaction.energy / len(self.particle)
        else:
            return self.interaction.energy
    else:
        return 0.0</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.scale_velocities"><code class="name flex">
<span>def <span class="ident">scale_velocities</span></span>(<span>self, factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale particles' velocities by <code>factor</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_velocities(self, factor):
    &#34;&#34;&#34;Scale particles&#39; velocities by `factor`.&#34;&#34;&#34;
    for p in self.particle:
        p.velocity *= factor</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.set_density"><code class="name flex">
<span>def <span class="ident">set_density</span></span>(<span>self, rho)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the system density to <code>rho</code> by rescaling the coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_density(self, rho):
    &#34;&#34;&#34;Set the system density to `rho` by rescaling the coordinates.&#34;&#34;&#34;
    if self.cell is None:
        return ValueError(&#39;cannot compute density without a cell&#39;)
    factor = (self.density / rho)**(1./len(self.cell.side))
    for particle in self.particle:
        particle.position *= factor
    self.cell.side *= factor</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.set_temperature"><code class="name flex">
<span>def <span class="ident">set_temperature</span></span>(<span>self, temperature)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset velocities to a Maxwellian distribution with fixed CM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_temperature(self, temperature):
    &#34;&#34;&#34;Reset velocities to a Maxwellian distribution with fixed CM.&#34;&#34;&#34;
    from .particle import fix_total_momentum
    T = temperature
    for p in self.particle:
        p.maxwellian(T)
    fix_total_momentum(self.particle)
    # After fixing the CM the temperature is not exactly the targeted one
    # Therefore we scale the velocities so as to get to the right T
    T_old = self.temperature
    if T_old &gt; 0.0:
        fac = (T/T_old)**0.5
        for p in self.particle:
            p.velocity *= fac</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, backend='matplotlib', *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, backend=&#39;matplotlib&#39;, *args, **kwargs):
    from .visualize import show_ovito
    from .visualize import show_matplotlib
    from .visualize import show_3dmol

    if backend == &#39;matplotlib&#39;:
        _show = show_matplotlib
    elif backend == &#39;ovito&#39;:
        _show = show_ovito
    elif backend == &#39;3dmol&#39;:
        _show = show_3dmol
    else:
        raise ValueError(&#39;unknown backend for visualization&#39;)
    return _show(self.particle, self.cell, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.total_energy"><code class="name flex">
<span>def <span class="ident">total_energy</span></span>(<span>self, per_particle=False, normed=None, cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the total energy of the system.</p>
<p>If <code>per_particle</code> or <code>normed</code> is <code>True</code>, return the total
energy per particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_energy(self, per_particle=False, normed=None, cache=False):
    &#34;&#34;&#34;
    Return the total energy of the system.

    If `per_particle` or `normed` is `True`, return the total
    energy per particle.
    &#34;&#34;&#34;
    if normed is not None:
        per_particle = normed
    return self.potential_energy(per_particle, cache=cache) + self.kinetic_energy(per_particle)</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, other, full=False, exclude=None, only=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update current system attributes in-place using the <code>other</code> System
as source.</p>
<p>The default behavior is to make deep copies only of all the
<code>other</code> system attributes that are not None, i.e. which are
set.</p>
<p>To overwrite all attributes, even those set in <code>self</code> but not
in <code>other</code>, use <code>full=True</code>.</p>
<p>The lists <code>exclude</code> and <code>only</code> can be used to avoid updating
some system attributes or to update only some system
attributes, respectively.</p>
<p>This method can be used by subclasses to deal with performace
or memory dellocation issues.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, other, full=False, exclude=None, only=None):
    &#34;&#34;&#34;
    Update current system attributes in-place using the `other` System
    as source.

    The default behavior is to make deep copies only of all the
    `other` system attributes that are not None, i.e. which are
    set.

    To overwrite all attributes, even those set in `self` but not
    in `other`, use `full=True`.

    The lists `exclude` and `only` can be used to avoid updating
    some system attributes or to update only some system
    attributes, respectively.

    This method can be used by subclasses to deal with performace
    or memory dellocation issues.
    &#34;&#34;&#34;
    for key in other.__dict__:
        if exclude is not None or only is not None:
            if (exclude is not None and key not in exclude) or \
               (only is not None and key in only):
                self.__dict__[key] = copy.deepcopy(other.__dict__[key])
        else:
            if full or other.__dict__[key] is not None:
                self.__dict__[key] = copy.deepcopy(other.__dict__[key])

    # Internal data dictionary for array dumps
    self._data = None</code></pre>
</details>
</dd>
<dt id="atooms.system.system.System.virial"><code class="name flex">
<span>def <span class="ident">virial</span></span>(<span>self, per_particle=True, cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the virial of the system.</p>
<p>If <code>per_unit_volume</code> is <code>True</code>, return the virial per particle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virial(self, per_particle=True, cache=False):
    &#34;&#34;&#34;
    Return the virial of the system.

    If `per_unit_volume` is `True`, return the virial per particle.
    &#34;&#34;&#34;
    if self.interaction is not None:
        if not cache or self.interaction.virial is None:
            self.compute_interaction(&#39;forces&#39;)
        if per_particle:
            return self.interaction.virial / len(self.particle)
        else:
            return self.interaction.virial
    else:
        return 0.0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atooms.system" href="index.html">atooms.system</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atooms.system.system.System" href="#atooms.system.system.System">System</a></code></h4>
<ul class="">
<li><code><a title="atooms.system.system.System.cm" href="#atooms.system.system.System.cm">cm</a></code></li>
<li><code><a title="atooms.system.system.System.cm_position" href="#atooms.system.system.System.cm_position">cm_position</a></code></li>
<li><code><a title="atooms.system.system.System.cm_velocity" href="#atooms.system.system.System.cm_velocity">cm_velocity</a></code></li>
<li><code><a title="atooms.system.system.System.compute_interaction" href="#atooms.system.system.System.compute_interaction">compute_interaction</a></code></li>
<li><code><a title="atooms.system.system.System.density" href="#atooms.system.system.System.density">density</a></code></li>
<li><code><a title="atooms.system.system.System.distinct_species" href="#atooms.system.system.System.distinct_species">distinct_species</a></code></li>
<li><code><a title="atooms.system.system.System.dump" href="#atooms.system.system.System.dump">dump</a></code></li>
<li><code><a title="atooms.system.system.System.fix_momentum" href="#atooms.system.system.System.fix_momentum">fix_momentum</a></code></li>
<li><code><a title="atooms.system.system.System.fold" href="#atooms.system.system.System.fold">fold</a></code></li>
<li><code><a title="atooms.system.system.System.force_norm" href="#atooms.system.system.System.force_norm">force_norm</a></code></li>
<li><code><a title="atooms.system.system.System.force_norm_square" href="#atooms.system.system.System.force_norm_square">force_norm_square</a></code></li>
<li><code><a title="atooms.system.system.System.kinetic_energy" href="#atooms.system.system.System.kinetic_energy">kinetic_energy</a></code></li>
<li><code><a title="atooms.system.system.System.number_of_dimensions" href="#atooms.system.system.System.number_of_dimensions">number_of_dimensions</a></code></li>
<li><code><a title="atooms.system.system.System.packing_fraction" href="#atooms.system.system.System.packing_fraction">packing_fraction</a></code></li>
<li><code><a title="atooms.system.system.System.particle" href="#atooms.system.system.System.particle">particle</a></code></li>
<li><code><a title="atooms.system.system.System.potential_energy" href="#atooms.system.system.System.potential_energy">potential_energy</a></code></li>
<li><code><a title="atooms.system.system.System.pressure" href="#atooms.system.system.System.pressure">pressure</a></code></li>
<li><code><a title="atooms.system.system.System.scale_velocities" href="#atooms.system.system.System.scale_velocities">scale_velocities</a></code></li>
<li><code><a title="atooms.system.system.System.set_density" href="#atooms.system.system.System.set_density">set_density</a></code></li>
<li><code><a title="atooms.system.system.System.set_temperature" href="#atooms.system.system.System.set_temperature">set_temperature</a></code></li>
<li><code><a title="atooms.system.system.System.show" href="#atooms.system.system.System.show">show</a></code></li>
<li><code><a title="atooms.system.system.System.species_layout" href="#atooms.system.system.System.species_layout">species_layout</a></code></li>
<li><code><a title="atooms.system.system.System.temperature" href="#atooms.system.system.System.temperature">temperature</a></code></li>
<li><code><a title="atooms.system.system.System.total_energy" href="#atooms.system.system.System.total_energy">total_energy</a></code></li>
<li><code><a title="atooms.system.system.System.update" href="#atooms.system.system.System.update">update</a></code></li>
<li><code><a title="atooms.system.system.System.virial" href="#atooms.system.system.System.virial">virial</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>